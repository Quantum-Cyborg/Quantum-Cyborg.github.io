<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>多世界研究所</title>
  <icon>https://quantum-cyborg.github.io/icon.png</icon>
  <subtitle>Multi-Worlds Research Institute</subtitle>
  <link href="https://quantum-cyborg.github.io/atom.xml" rel="self"/>
  
  <link href="https://quantum-cyborg.github.io/"/>
  <updated>2024-04-13T04:12:47.552Z</updated>
  <id>https://quantum-cyborg.github.io/</id>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cold Atom: Bragg spectroscopy (布拉格光谱学) - 基本理论</title>
    <link href="https://quantum-cyborg.github.io/2024/04/06/Physics/Bragg%20spectroscopy/"/>
    <id>https://quantum-cyborg.github.io/2024/04/06/Physics/Bragg%20spectroscopy/</id>
    <published>2024-04-05T16:00:00.000Z</published>
    <updated>2024-04-13T04:12:47.552Z</updated>
    
    <content type="html"><![CDATA[<p>自上世纪80年代末以来，布拉格(Bragg)散射和光谱学已经在超冷原子气体领域得到了应用。布拉格光谱学不仅能够揭示气体的单粒子谱，还能够揭示气体的集体模式谱。<span id="more"></span>在1999年，文献[1]和[2]是将布拉格光谱学应用于玻色-爱因斯坦凝聚体研究的第一批实验。在2008年，文献[3]第一次利用Bragg光谱学来测量费米气体的动态<span class="math inline">\(S(k,\omega)\)</span> 和静态 <spanclass="math inline">\(S(k)\)</span> 结构因子。动态和静态结构因子 <spanclass="math inline">\(S(k,\omega)\)</span> 和 <spanclass="math inline">\(S(k)\)</span>实际上包含了关于单粒子和集体激发的信息。在超冷原子气体以外的其他系统中，各种类型的散射方法都被广泛用来确定动态和静态结构因子。例如，在液态氦的情况下，静态结构因子可以通过X射线和中子散射来测量。</p><p>在超冷原子的布拉格光谱实验中，一般将两束激光对准原子云团，这两束激光是非共振的，并且彼此间具有特定的夹角和频率差。当这两束非共振激光照射到原子云时，会破坏原有的热力学平衡状态，进而诱发原子密度发生变化。形象地说，实验中一部分原子经历了一个双光子布拉格过程：这些原子首先从一束激光中吸收一个光子，接着通过受激辐射向另一束激光释放一个光子。由于两束激光之间的动量和能量不匹配，这一吸收和发射过程使得原子自身的能量和动量发生了变化。</p><p>Bragg光谱学在概念上与射频光谱学有两个不同之处：</p><ul><li>首先，它不会改变粒子的内部状态；</li><li>其次，它会给粒子带来一定的动量变化。在RF光谱学中，初始态对应于算符<spanclass="math inline">\(\hat{c}^\dagger_{kg}\)</span>，而最终态对应于<spanclass="math inline">\(\hat{c}^\dagger_{ke}\)</span>.而在Bragg光谱学中，初始态对应于 <spanclass="math inline">\(\hat{c}^\dagger_{kg}\)</span>，最终态则对应于<span class="math inline">\(\hat{c}^\dagger_{k+q,g}\)</span>，其中 <spanclass="math inline">\(q\)</span> 是在Bragg过程中给气体的动量。</li></ul><p>一般来说，Bragg过程会给系统给出一个微扰项： <spanclass="math display">\[\hat{H}_{\rm br}(t)=\int d^3r\ V_{\rmbr}(\mathbf{r},t)  \hat{n}(\mathbf{r}).\]</span> 其中 <spanclass="math inline">\(V_{\rm br}(\mathbf{r},t)\)</span> 是 Bragg光所产生的 source term，它耦合到了原子气的密度算符上去，表示了 Bragg过程所引起的原子气体的密度响应。由于 Bragg过程中的两束光具有相同的偏振，会相互干涉，因此它所产生的外势场如下式所示是随时间变化的：<span class="math display">\[\begin{aligned}V_{\mathrm{br}}(r,t)&amp; =V_0\cos(\omega_\text{br}t-k_\text{br}\cdotr)  \\&amp;=\frac{V_0}2\left[\mathrm{e}^{i(\omega_\mathrm{br}t-\mathbf{k}_\mathrm{br}\cdot\mathbf{r})}+\mathrm{e}^{-i(\omega_\mathrm{br}t-\mathbf{k}_\mathrm{br}\cdot\mathbf{r})}\right],\end{aligned}\]</span> 这里的 <span class="math inline">\(V_0\)</span>是含时外势场的振幅，<spanclass="math inline">\(\omega_\mathrm{br}\)</span> 和 <spanclass="math inline">\(\mathbf{k}_\mathrm{br}\)</span>分别是两束光的波矢差和角频率差。</p><p>在最初的情况下，原子气体是处于平衡态的。当加上这个扰动之后，系统的密度分布将会出现响应而发生变化<span class="math inline">\(\deltan(\mathbf{r},t)\)</span>，也就是会偏离原先平衡态下的均匀分布。当扰动足够小的时候，线性响应理论就会给出如下的密度变化：<span class="math display">\[\delta n( \mathbf{r},t) = \int \mathrm{d}^3 \mathbf{r}&#39; \int\mathrm{d}t&#39; \\chi_{nn}(\mathrm{r}-\mathrm{r}&#39;,t-t&#39;)V_{\mathrm{br}}(\boldsymbol{r}&#39;,t&#39;),\]</span> 当然，在频率空间中会更加地简单：<spanclass="math inline">\(\deltan(k,\omega)=\chi_{nn}(k,\omega)V_{\mathrm{br}}(k,\omega)\)</span>.这里的 <span class="math inline">\(\chi_{nn}(k,\omega) = \langle[\hat{n}(k),\hat{n}(−k)]\rangle\)</span> 就是密度-密度响应函数。</p><p>这里密度的变化在实验上是一个可观测量，进而可以知道密度-密度响应函数。再根据大名鼎鼎的涨落耗散定理<spanclass="math display">\[\mathrm{Im}\Big[\chi_{nn}(k,\omega)\Big]=-\pin_0\Big(1-\mathrm{e}^{-\beta\hbar\omega}\Big)S(k,\omega),\]</span>我们就可以得到结构因子的结果。</p><hr /><div id="refer"></div><ul><li>[1] M. Kozuma, L. Deng, E. W. Hagley, etc, <em>"Coherent splittingof Bose–Einstein condensed atoms with optically induced Braggdiffraction".</em> <em>Phys. Rev. Lett</em>. 82, 871–875 (1999).</li><li>[2] J. Stenger, S. Inouye, etc, <em>"Bragg spectroscopy of aBose–Einstein condensate".</em> <em>Phys. Rev. Lett</em>. 82, 4569–4573(1999).</li><li>[3] G. Veeravalli, E. Kuhnle, P. Dyke, and C. J. Vale, <em>"Braggspectroscopy of a strongly interacting Fermi gas".</em> <em>Phys. Rev.Lett</em>. 101, 250403 (2008).</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;自上世纪80年代末以来，布拉格(Bragg)
散射和光谱学已经在超冷原子气体领域得到了应用。布拉格光谱学不仅能够揭示气体的单粒子谱，还能够揭示气体的集体模式谱。</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Atom-Optics" scheme="https://quantum-cyborg.github.io/tags/Atom-Optics/"/>
    
  </entry>
  
  <entry>
    <title>Cold Atom: 射频谱学 学习笔记</title>
    <link href="https://quantum-cyborg.github.io/2024/04/06/Physics/Radio-frequency%20spectroscopy/"/>
    <id>https://quantum-cyborg.github.io/2024/04/06/Physics/Radio-frequency%20spectroscopy/</id>
    <published>2024-04-05T16:00:00.000Z</published>
    <updated>2025-09-02T00:51:46.756Z</updated>
    
    <content type="html"><![CDATA[<p>射频谱学是探测原子气体的一种强大工具，它允许我们以可控的方式向原 子转移能量。通过施加特定频率的振荡电磁场（射频场），我们可以选择性地激发气体中的原子到更高的能级。射频场频率通常在 MHz 至 GHz 范围内，在更高频率下我们一般称其为微波场，这两者没有本质的区别，都对应于不同原子态之间的能级间隔。</p><p>射频光谱学的历史可以追溯到二十世纪二三十年代，人们开始研究原子气体的光谱。当时，研究原子光谱的主要工具是光学光谱学，观察原子对光的吸收和发射。然而，光学光谱学在研究磁场中的原子时受到了限制。到了二十世纪四五十年代，研究人员开始将射频光谱学作为光学光谱学的补充工具。实验发现通过在磁场中的原子气体中施加射频场，可以诱导不同原子态之间的跃迁，这使人们能够研究磁场中原子光谱的详细结构。在接下来的几十年中，射频谱技术被广泛地应用于研究磁共振、超精细结构和塞曼分裂等现象。本节中我将介绍超冷原子物理中射频的工作原理、射频谱技术的实验应用。</p><h2 id="原子光谱">原子光谱</h2><p>在冷原子系统中，尤其是在量子模拟中，常常使用相近的几个超精细结构的能级。</p><table><thead><tr class="header"><th style="text-align: center;"><img src="energy_level.png" /> <img src="hyperfine_energy_level.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em><span class="math inline">\(^{87}Rb\)</span> 原子的能级，以及在磁场情况下的超精细结构。这两张图片摘录自<sup>[1]</sup>.</em></td></tr></tbody></table><p><strong>射频</strong>：3 kHz 至 300 GHz</p><p><strong>微波</strong>：波长介于红外线和无线电波，频率范围大约在 300MHz 至300GHz.</p><p>这两者并没有本质的区别 射频特点：射频光谱学的一个显著特点是：​<strong>射频场的波长远大于系统中的其他特征长度尺度</strong>。具体来说，射频波长通常比原子云的尺寸大得多。这一特性带来了两个关键影响：</p><ol type="1"><li><p>​<strong>动量可忽略</strong>​</p><p>与系统的典型动量尺度（如费米动量）相比，射频场所对应的动量几乎可以忽略不计。</p></li><li><p>​<strong>均匀耦合</strong>​</p><p>由于射频波长远大于原子云，其强度在原子云尺度上可视为均匀分布。因此，耦合参数可以简化为一个常数： <span class="math display">\[ \Omega(r) = \Omega \exp(i k {\bf L} \cdot {\bf r}) = \Omega \]</span></p><p>这意味着，在粒子从基态（g）跃迁到激发态（e）的过程中，​<strong>动量守恒</strong>直接体现在初态和末态的动量关系上，而无需额外考虑射频场带来的动量变化。 这种均匀耦合的特性使得理论分析更加简洁，同时也为实验调控提供了便利。</p></li></ol><h2 id="无相互作用情况拉比震荡">无相互作用情况（拉比震荡）</h2><table><thead><tr class="header"><th style="text-align: center;"><img src="Rabi.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>(a) 拉比震荡示意图。(b) 固定时间<span class="math inline">\(\pi/\Omega\)</span>下，原子处于激发态的概率与失谐的关系。From the paper<sup>[1]</sup>.</em></td></tr></tbody></table><p><span class="math inline">\(t\)</span> 时刻原子处于激发态的概率为： <span class="math display">\[P_b(t)=\frac{N_b}{N_a+N_b}=\frac{\Omega^2}{\Omega^2+\delta^2}\sin^2(\frac{\sqrt{\Omega^2+\delta^2}}{2}t).\]</span> 当射频频率不完全共振时，在 <span class="math inline">\(\Omega t=\pi\)</span> 时原子处于 <span class="math inline">\(|b\rangle\)</span> 态的概率与射频失谐的关系见图1(b)。</p><h3 id="真实实验">真实实验</h3><table><thead><tr class="header"><th style="text-align: center;"><img src="2DSOC_band.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>From paper <sup>[2]</sup></em></td></tr></tbody></table><p>下面两个能带是 <span class="math inline">\(|1,-1\rangle\)</span> 和 <span class="math inline">\(|1,-0\rangle\)</span>,</p><h2 id="相互作用情况">相互作用情况</h2><h3 id="mean-field-cases">Mean-Field cases</h3><p>这个例子来自于2003年的一篇Science文章，这是首次在实验中用于研究强相互作用费米气体平均场能量的方法。</p><p>处于 <span class="math inline">\(|2\rangle\)</span> 态的原子会受到 <span class="math inline">\(|1\rangle\)</span> 态原子的影响而产生能量偏移<span class="math inline">\([(4\pi\hbar^2)/(m)]n_1a_{12}\)</span>。其中 <span class="math inline">\(\hbar\)</span> 是普朗克常数 <span class="math inline">\(h\)</span> 除以 <span class="math inline">\(2\pi\)</span>，<span class="math inline">\(m\)</span> 是原子质量，<span class="math inline">\(n_1\)</span> 是 <span class="math inline">\(|1\rangle\)</span> 态原子的密度，<span class="math inline">\(a_{12}\)</span> 是 <span class="math inline">\(|1\rangle\)</span> 态和 <span class="math inline">\(|2\rangle\)</span> 态之间的散射长度。</p><p>对于一个密度为 <span class="math inline">\(n\)</span> 的系统，我们比较纯 <span class="math inline">\(|1\rangle\)</span> 态气体与将一个原子转移到<span class="math inline">\(|2\rangle\)</span> 态后的气体能量。其能量差为 <span class="math inline">\(h\nu_{12}+[(4\pi\hbar^{2})/(m)]na_{12}\)</span>，其中 <span class="math inline">\(\nu_{12}\)</span> 是无相互作用系统的共振频率。</p><p>如图 (6.2) 所示， <span class="math inline">\(|1\rangle\)</span> 、 <span class="math inline">\(|2\rangle\)</span> 是具有相互作用的两个能态， <span class="math inline">\(|3\rangle\)</span> 是探测态，其对应 <span class="math inline">\(|2\rangle\)</span> 原子射频跃迁后的状态。实验上测量了从单 <span class="math inline">\(|2\rangle\)</span> 态到 <span class="math inline">\(|3\rangle\)</span> 态的射频共振频率和 <span class="math inline">\(|1\rangle|2\rangle\)</span> 混态中从 <span class="math inline">\(|2\rangle\)</span> 态到 <span class="math inline">\(|3\rangle\)</span> 态的射频共振频率之差。 <span class="math display">\[\Delta\nu=\frac{2\hbar}{m}n_{1}(a_{12}-a_{23}).\]</span> 这里 <span class="math inline">\(a_{12}\)</span> 和 <span class="math inline">\(a_{23}\)</span> 分别是各态之间的散射长度。当 <span class="math inline">\(a_{23}\)</span> 趋近于零时，我们测得的便是 <span class="math inline">\(|1\rangle - |2\rangle\)</span> 之间的相互作用强度。这种平均场位移在原子钟实验中被称为“时钟漂移”, 是其实验系统误差的主要来源之一。</p><table><thead><tr class="header"><th style="text-align: center;"><img src="RF_Spectroscopy.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>From paper <sup>[3]</sup>.</em></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;射频谱学是探测原子气体的一种强大工具，它允许我们以可控的方式向原 子转移能量。通过施加特定频率的振荡电磁场（射频场），我们可以选择性地激发气体中的原子到更高的能级。射频场频率通常在 MHz 至 GHz 范围内，在更高频率下我们一般称其为微波场，这两者没有本质的区别，都对应于</summary>
      
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Atom-Optics" scheme="https://quantum-cyborg.github.io/tags/Atom-Optics/"/>
    
  </entry>
  
  <entry>
    <title>手征反常与轴子</title>
    <link href="https://quantum-cyborg.github.io/2023/12/29/Physics/Chiral%20Anomaly%20and%20Axion/"/>
    <id>https://quantum-cyborg.github.io/2023/12/29/Physics/Chiral%20Anomaly%20and%20Axion/</id>
    <published>2023-12-28T16:00:00.000Z</published>
    <updated>2025-09-02T00:41:15.886Z</updated>
    
    <content type="html"><![CDATA[<h1 id="手征反常">手征反常</h1><p>我们都知道，诺特定理告诉我们，如果系统的作用量在某一变换下不变，则存在对应的守恒流。不过这是经典场论的结论，在量子化之后，这个结论还能成立吗？大多数情况下，这个定理是有量子版本的对应的，但是在某些情况，这一定理的量子版本就不再成立了。我们把经典系统的对称性在量子化后丢失的现象叫做量子反常。</p><p>现在已知好多种量子反常，比如手征反常、规范反常、引力反常 等。我们这里介绍的是历史上最早发现的手征反常，又称为：轴矢反常、Adler-Bell-Jackiw（ABJ）反常或者三角反常。从历史上看，量子反常这个名字的由来，是源于“量子效应对经典对称性的破坏”的描述。</p><p>我们首先介绍狄拉克场，然后看看狄拉克场中的量子反常。</p><h2 id="狄拉克场">狄拉克场</h2><p>狄拉克场的拉氏量可以写为： <span class="math display">\[\mathscr{L}=\bar{\psi} \gamma^\mu\left(i \partial_\mu+e A_\mu+b_\mu \gamma^5\right) \psi-m \bar{\psi} \psi\]</span> 这里 <span class="math inline">\(\bar{\psi}=\psi^{\dagger} \gamma^0\)</span>，而 <span class="math inline">\(m\)</span> 则代表狄拉克费米子的质量。费米子与外部轴矢势 <span class="math inline">\(b_\mu \equiv A_\mu^5\)</span> 耦合。狄拉克 <span class="math inline">\(\gamma-\)</span>矩阵满足反对易关系 <span class="math inline">\(\left\{\gamma^\mu, \gamma^\nu\right\}=-2 \eta^{\mu \nu}\)</span>，其中 <span class="math inline">\(\eta_{\mu \nu}=\operatorname{diag}(-1,1,1,1)\)</span>，使得 <span class="math inline">\(\gamma^0=(\gamma^0)^{\dagger}\)</span> 是厄米的，而 <span class="math inline">\(\gamma^i=-(\gamma^i)^{\dagger}\)</span> 是反厄米的。手征矩阵 <span class="math inline">\(\gamma^5 \equiv =i \gamma^0 \gamma^1 \gamma^2 \gamma^3=(\gamma^5)^{\dagger}\)</span> 也是厄米的，其特征值 <span class="math inline">\(\pm 1\)</span> 分别对应于右手和左手手征性。</p><h2 id="两种守恒量">两种守恒量</h2><p>狄拉克场的拉氏量在局域 <span class="math inline">\(U(1)^{\mathrm{EM}}\)</span> 相位变换下保持不变，同时还存在另一种局域手征相位变换 <span class="math inline">\(U(1)^{\text {ch }}\)</span>。这两种变换分别对应着电荷守恒和手征守恒： 1. 拉氏量在局域 <span class="math inline">\(U(1)^{\mathrm{EM}}\)</span> 相位变换下不变 <span class="math display">\[\psi \rightarrow e^{i \alpha} \psi, \quad \bar{\psi} \rightarrow \bar{\psi} e^{-i \alpha}, \quad e A_\mu \rightarrow e A_\mu+\partial_\mu \alpha\]</span> 2. 第二个变换是局域手征相位变换 <span class="math inline">\(U(1)^{\text {ch }}\)</span> <span class="math display">\[\psi \rightarrow e^{i \beta \gamma^5} \psi, \quad \bar{\psi} \rightarrow \bar{\psi} e^{i \beta \gamma^5}, \quad b_\mu \rightarrow b_\mu+\partial_\mu \beta,\]</span> 其中右手和左手手征性以相反方式变换。</p><ul><li><span class="math inline">\(U(1)^{\mathrm{EM}}\)</span> 变换可以“吞并”并进一步与矢势 <span class="math inline">\(\mathbf{A}\)</span>相互抵消。</li><li><span class="math inline">\(U(1)^{\mathrm{ch}}\)</span> 变换则可以“吞并”轴矢势 <span class="math inline">\(b_\mu\)</span>。当 <span class="math inline">\(\beta=b_\mu x^\mu=\mathbf{b}\cdot\mathbf{r}-b_0t\)</span> 时，轴矢势会被完全抵消掉。</li></ul><p>根据诺特定理，这两个经典不变性意味着<strong>电流</strong>和<strong>轴向</strong>电流的守恒， <span class="math display">\[J^\mu=\frac{\delta S}{\delta A_\mu}=e \bar{\psi} \gamma^\mu \psi, \quad J_5^\mu=\frac{\delta S}{\delta b_\mu}=\bar{\psi} \gamma^\mu \gamma^5 \psi\]</span> 其中 <span class="math display">\[\partial_\mu J^\mu=0, \quad \partial_\mu J_5^\mu=2im \bar{\psi} \gamma^5 \psi\]</span> 可以看到轴矢流仅仅在 <span class="math inline">\(m=0\)</span> 时守恒。因此，当 <span class="math inline">\(m=0\)</span> 时，出现明显的 <span class="math inline">\(U(1)^{\mathrm{EM}} \otimes U(1)^{\mathrm{ch}}\)</span> 对称性。</p><h2 id="量子情况">量子情况</h2><p>事实上，在量子理论中，不可能同时满足 <span class="math inline">\(U(1)^{\mathrm{EM}}\)</span> 规范不变性和 <span class="math inline">\(U(1)^{\mathrm{ch}}\)</span> 手征不变性。</p><h3 id="从测度项来看">从测度项来看</h3><p>在量子理论中，我们需要考虑测度的变换， <span class="math display">\[\mathcal{D} \psi \mathcal{D} \bar{\psi} \to \mathcal{D} \psi \mathcal{D} \bar{\psi} \ \rm{det}[e^{i \beta \gamma^5}] = \mathcal{D} \psi \mathcal{D} \bar{\psi} \  e^{i \Delta S_\theta}\]</span> 这里 <span class="math inline">\(\Delta S_\theta =\mathrm{Tr} [\theta(x)\gamma^5]\)</span>，因此我们得到了变换后的配分函数 <span class="math display">\[Z^{\prime}=\int \mathcal{D} \psi \mathcal{D} \bar{\psi} \ e^{i\left(S+\Delta S_\theta\right)}\]</span></p><p>其中 <span class="math display">\[\begin{aligned}&amp; S=\int d^4 x \bar{\psi} i \gamma^\mu\left(\partial_\mu+i A_\mu\right) \psi=\int d^4 x \bar{\psi} i \gamma^\mu D_\mu \psi, \\&amp; \Delta S_\theta=\operatorname{Tr}\left[\theta(x) y^5\right]=\int d^4 x \theta(x) \bar{\psi} \gamma^5 \psi .\end{aligned}\]</span></p><p><span class="math display">\[\gamma^\mu D_\mu \phi_n(x)=\varepsilon_n \phi_n(x)\]</span></p><p>在 <span class="math inline">\(S_D\)</span> 的本征态下，反常作用量 <span class="math inline">\(\Delta S_\theta\)</span> 可以写为 <span class="math display">\[\Delta S_\theta=\int d^4 x \theta(x) \sum_n \phi_n^*(x) \gamma^5 \phi_n(x),\]</span></p><p>积掉费米子场，最终反常作用量为 <span class="math display">\[\Delta S_\theta = \int \mathrm{d}^4x \ \theta(x) \mathbf{A}(x) = \frac{e^2}{32\pi^2} \int  \mathrm{d}^4x \ \theta(x) \epsilon^{\mu\nu\rho\lambda} F_{\mu\nu} F_{\rho\lambda}\]</span> 这给出了手征反常电流方程 <span class="math display">\[\partial_\mu J^\mu_5 = -\frac{e^2}{16\pi^2} \epsilon^{\mu\nu\rho\lambda} F_{\mu\nu} F_{\rho\lambda}=\frac{2\alpha}{\pi} \mathbf{E} \cdot \mathbf{B}\]</span></p><h3 id="从费曼图来看">从费曼图来看</h3><p>这些对称性的冲突首次出现在三角图的单圈级别： <img src="triangle_diagram.png" /></p><p>该单圈图中评估费米子三角振幅的过程， <span class="math display">\[\Gamma_5^{\mu \alpha \beta}(p, q)=\left.i \int d^4 x \int d^4 y e^{i p \cdot x+i q \cdot y}\left\langle 0\left|\mathcal{T} J_5^\mu(0) J^\alpha(x) J^\beta(y)\right| 0\right\rangle\right|_{A=0}\]</span> 通过施加低能理论的适当对称性来进行动量空间中的计算。</p><h1 id="轴子电动力学">轴子电动力学</h1><p>完整的作用量包含了三部分：狄拉克费米子、电磁场以及反常部分 <span class="math inline">\(S=S_D+S_{E M}+\Delta S_\theta\)</span>， <span class="math display">\[\begin{gathered}S_D=\int d^4 x \bar{\psi} i \gamma^\mu\left(\partial_\mu+i A_\mu\right) \psi, \\S_{E M}=-\frac{1}{4} \int d^4 x F_{\mu \nu} F^{\mu \nu}, \\\Delta S_\theta=\frac{e^2}{32 \pi^2} \int d^4 x \theta(x) \epsilon^{\mu \nu \rho \lambda} F_{\mu \nu} F_{\rho \lambda} .\end{gathered}\]</span></p><p>积掉狄拉克费米子场使其仅仅成为背景，并且他会影响介电常数 <span class="math inline">\(\epsilon\)</span> 和 <span class="math inline">\(\mu\)</span>，于是我们只留下了关于电磁场的方程：</p><p><span class="math display">\[\begin{gathered}\boldsymbol{\nabla} \cdot(\mathbf{E}-c \kappa \theta \mathbf{B})=\frac{\rho_e}{\epsilon_0}, \\\nabla \times(c \mathbf{B}+\kappa \theta \mathbf{E})=\partial_t(\mathbf{E}-c \kappa \theta \mathbf{B}) / c+c \mu_0 \mathbf{J}_e, \\\boldsymbol{\nabla} \cdot(c \mathbf{B}+\kappa \theta \mathbf{E})=0, \\\nabla \times(\mathbf{E}-c \kappa \theta \mathbf{B})+\partial_t(c \mathbf{B}+\kappa \theta \mathbf{E}) / c=0, \\\square \theta=-\frac{\kappa}{\mu_0 c} \mathbf{E} \cdot \mathbf{B}-\frac{\partial U(\theta)}{\partial \theta} .\end{gathered}\]</span> 从方程中我们可以观察到三个明显的性质： 1. 电场与轴子耦合在一起会形成等效的磁场：<span class="math inline">\((c \mathbf{B}+\kappa \theta \mathbf{E})\)</span>. 2. 而磁场与轴子耦合在一起则会形成等效的电场：<span class="math inline">\((\mathbf{E}-c \kappa \theta \mathbf{B})\)</span>. 3. 垂直的磁场和电场 <span class="math inline">\(-\frac{\kappa}{\mu_0 c} \mathbf{E} \cdot \mathbf{B}\)</span> 可以产生轴子，可以形成轴子源。</p><h2 id="外尔半金属中的轴子">外尔半金属中的轴子</h2><p>外尔半金属（Weyl semimetals）是一类具有non-trivial拓扑性质的材料。在外尔半金属中，电子的能带结构中会出现一种叫做“外尔点”（Weyl points）的特殊交点，这些交点对应着一种质量为零的费米子，这种费米子被称为外尔费米子。每个外尔点都具有特定的手征性，并且总是正反手性成对出现（这是晶格模型的特征）。同时轴子也可以出现在外尔半金属中，但在外尔半金属中，轴子并不直接对应于粒子物理中的基本轴子，而是指一种拓扑性质，和外尔半金属中的电磁响应紧密相连。</p><p>轴子在外尔半金属中的作用可以通过“轴子电磁响应”来理解，这种响应机制可以影响材料的电磁性质。</p><p>通过动态介电常数响应，拓扑磁电效应等，以及在波导结构中的应用。设 <span class="math inline">\(\rho=\mathbf{J}=0\)</span> 得到 <span class="math display">\[\omega^2-k^2= \pm\left(p_0 k-\omega p \cos \varphi\right)\left[1-\frac{p^2 \sin ^2 \varphi}{\omega^2-k^2}\right]^{-\frac{1}{2}}\]</span></p><p>其中<span class="math inline">\(p=\frac{e^2}{2\pi^2}b\)</span>，<span class="math inline">\(p_0=\frac{e^2}{2\pi^2}b_0\)</span>，<span class="math inline">\(\varphi\)</span> 是 <span class="math inline">\(\mathbf{p}\)</span> 和 <span class="math inline">\(\boldsymbol{k}\)</span> 之间的夹角，<span class="math inline">\(\pm\)</span> 代表左右手圆偏振光极化方向。这个色散关系还是比较复杂的，上式复杂的右边项是由手征反常导致的，而左边则是光学上线性色散 <span class="math inline">\(\omega= \pm k\)</span> 。</p><p><strong>1. 双折射</strong> 为了看出双折射的效应，不妨做一个想象实验：将一束沿着 <span class="math inline">\(z\)</span> 方向传播的平面波，同时 Weyl 半金属中 <span class="math inline">\(p\)</span> 也设为 <span class="math inline">\(z\)</span> 方向，则夹角 <span class="math inline">\(\varphi=0\)</span>，上式可化为 <span class="math display">\[\omega \approx \pm \sqrt{k_z^2 \pm\left(p_0-p\right) k_z} .\]</span></p><p>对右边项进行零阶近似即 <span class="math inline">\(\omega=k_z\)</span>，因此得到一个有效的色散关系。一般情况下，<span class="math inline">\(\delta=\left(p_0-p\right)\)</span> 是一个小量，从上式可以明显看出在 <span class="math inline">\(z\)</span> 方向传播的光场会出现两个等相位面，这就是 Weyl 半金属中手征反常造成的双折射现象。</p><p><strong>2. 速子</strong> 另一个极端情况是当 <span class="math inline">\(k_z&lt;\delta\)</span> 时，其中一支模式会变成虚频率，在场论中被认为是速子模式（tachyon，一种超光速的粒子激发），然而在实际材料中，其传播是指数衰减的消逝波模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;手征反常&quot;&gt;手征反常&lt;/h1&gt;
&lt;p&gt;我们都知道，诺特定理告诉我们，如果系统的作用量在某一变换下不变，则存在对应的守恒流。不过这是经典场论的结论，在量子化之后，这个结论还能成立吗？大多数情况下，这个定理是有量子版本的对应的，但是在某些情况，这一定理的量子版本就不</summary>
      
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Axion" scheme="https://quantum-cyborg.github.io/tags/Axion/"/>
    
    <category term="QFT" scheme="https://quantum-cyborg.github.io/tags/QFT/"/>
    
  </entry>
  
  <entry>
    <title>存点图 记录生活</title>
    <link href="https://quantum-cyborg.github.io/2023/12/24/Life/New_Zealand_Life/"/>
    <id>https://quantum-cyborg.github.io/2023/12/24/Life/New_Zealand_Life/</id>
    <published>2023-12-23T16:00:00.000Z</published>
    <updated>2023-12-24T16:41:15.324Z</updated>
    
    <content type="html"><![CDATA[<p>最近有在慢慢感受</p><p>在很偶然的某次骑行 我爱上了眼前的这个画面 <span id="more"></span></p><div class="line-block"><img src="1.jpg" /><img src="2.jpg" /></div><p>于是有了第二次骑行的快乐</p><p>图片（没带手机出门，没拍下来）</p><p>一股脑闯进了清晨时分雾气腾腾的大海</p><div class="line-block"><img src="3.jpg" /></div><p>下午变成颜色深浅不一的大海</p><div class="line-block"><img src="4.jpg" /></div><p>想踩 不同质感的土地</p><div class="line-block"><img src="5.jpg" /><img src="6.jpg" /><imgsrc="7.jpg" /><img src="8.jpg" /></div><p>躺着晒着听着闻着 我在感受</p><div class="line-block"><img src="9.jpg" /></div><p>在被晒得热乎乎的石头上躺</p><div class="line-block"><img src="10.jpg" /></div><p>海带尝了，硬硬的有点像皮带不是印象里小时候妈妈煮的海带绿豆粥的味道</p><div class="line-block"><img src="11.jpg" /></div><p>海草也用脚勾上来吃了，感觉应该还没我的脚好吃。不是波力海苔的味道</p><div class="line-block"><img src="12.jpg" /></div><p>凌晨去跟风拍极光 体验到了，风大 冷 吹得老子头疼，第二天还要上班打工又厌世了</p><div class="line-block"><img src="13.jpg" /></div><p>还是在青青草原上继续躺着晒太阳吧 （就是喜羊羊村里面那个偷跑进来了，这块草地真好闻</p><div class="line-block"><img src="14.jpg" /><img src="15.jpg" /></div><p>最后我很喜欢抓拍到的这张，被阳光直射眼睛得有点恼羞成怒了的自己，让我产生了一种热爱生活的错觉。</p><div class="line-block"><img src="16.jpg" /></div><p>12.24 傍晚九点 散步 祝各位 Merry Christmas 啦。</p><div class="line-block"><img src="17.jpg" /><img src="18.jpg" /><imgsrc="20.jpg" /><img src="21.jpg" /><img src="22.jpg" /><imgsrc="23.jpg" /><img src="24.jpg" /></div><p>按照禅的说法 我机缘巧合下来到这里应该是缘分在大自然中得到治愈，给自己擦灰，常问 去除外在的东西，我还剩什么呢？</p><p>未完待续</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近有在慢慢感受&lt;/p&gt;
&lt;p&gt;在很偶然的某次骑行 我爱上了眼前的这个画面</summary>
    
    
    
    <category term="Life" scheme="https://quantum-cyborg.github.io/categories/Life/"/>
    
    
    <category term="风景" scheme="https://quantum-cyborg.github.io/tags/%E9%A3%8E%E6%99%AF/"/>
    
    <category term="生活" scheme="https://quantum-cyborg.github.io/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Kitaev Honeycomb Model (I)</title>
    <link href="https://quantum-cyborg.github.io/2022/12/24/Physics/Kitaev%20Honeycomb%20Model/"/>
    <id>https://quantum-cyborg.github.io/2022/12/24/Physics/Kitaev%20Honeycomb%20Model/</id>
    <published>2022-12-24T04:30:00.000Z</published>
    <updated>2023-12-26T05:38:29.877Z</updated>
    
    <content type="html"><![CDATA[<p>The Kitaev honeycomb model is an exactly solvable model, whichdemonstrates the properties of a spin liquid state, specifically thetopological nature and the presence of anyonic excitations. It also hasbeen proposed as a possible platform for fault-tolerant quantumcomputation, due to its topological nature and the presence of anyonicexcitations. <span id="more"></span> The model consists of a honeycomb lattice witha spin-<span class="math inline">\(1/2\)</span> particle sitting on eachof its vertices. There are three types of links and we label them as<span class="math inline">\(x\)</span>, <spanclass="math inline">\(y\)</span> and <spanclass="math inline">\(z\)</span>, as showed in the figure.</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Kitaev_Wp.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Kitaev honeycomb model and the"plaquette operator" <span class="math inline">\(W_p\)</span></em></td></tr></tbody></table><p>The spins interact with their nearest neighbors via three differenttypes of links. Then the interaction can be written as <spanclass="math display">\[H=-J_x \sum_\text{x-links}\sigma_j^x\sigma_k^x -J_y\sum_\text{y-links}\sigma_j^y\sigma_k^y -J_z\sum_\text{z-links}\sigma_j^z\sigma_k^z\]</span></p><ul><li>The model is characterized by infinitely many local conservedquantities, the integrals of motion.</li></ul><h3 id="plaquette-operator-w_p">Plaquette Operator <spanclass="math inline">\(W_p\)</span></h3><p>The "plaquette operator" <span class="math inline">\(W_p\)</span> isdefined individually around each hexagonal loop as <spanclass="math display">\[W_p \equiv\sigma_1^x\sigma_2^y\sigma_3^z\sigma_4^x\sigma_5^y\sigma_6^z.\]</span>Each spin component acts only at a vertex where the external bond is inthe corresponding direction.</p><ul><li>Each <span class="math inline">\(W_p\)</span> commute withHamiltonian and with each other. Consequently, the <spanclass="math inline">\(W_p\)</span>'s can be independently diagonalizedwith eigenvalues <span class="math inline">\(W_p=\pm 1\)</span>.</li><li>The Hilbert space can thus be split into manifolds defined bydifferent values of set <spanclass="math inline">\(\{W_p\}\)</span>.</li><li>For “ferromagnetic” interactions <spanclass="math inline">\(J_{x,y,z}&gt;0\)</span>, the ground state lies inthe sector <span class="math inline">\(W_p=+1\)</span> for <spanclass="math inline">\(\forall p\)</span>.</li><li>We call the <span class="math inline">\(W_p=-1\)</span> state avortex and the <span class="math inline">\(W_p=+1\)</span> state vortexfree. The vortices display anyonic statistics (details in the belowsection).</li><li>Degeneracy: Original Hilbert space: <spanclass="math inline">\(2^n\)</span>-dimension (<spanclass="math inline">\(n\)</span> is vertices number). d.o.f. of <spanclass="math inline">\(\{W_p\}\)</span>: <spanclass="math inline">\(n/2\)</span>, number of plaquettes. Hence eachsector is <span class="math inline">\(2^{n/2}\)</span>-dimensionaldegenerate.</li></ul><h3 id="representing-spins-by-majorana-fermions">Representing spins byMajorana fermions</h3><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Kitaev_representation_majorana.png"alt="Representing Spins by Majorana Fermions" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Representing Spins by MajoranaFermions</em></td></tr></tbody></table><p>As shown in the figure above, we mathematically replace the spinoperator <span class="math inline">\(S^\gamma\)</span> <spanclass="math inline">\((\gamma=x,y,z)\)</span> by two types of Majoranaoperators <span class="math inline">\(b^\gamma\)</span> and <spanclass="math inline">\(c\)</span>: <spanclass="math inline">\(S^\gamma=\frac{i}{2}b^{\gamma}c\)</span>. Here theMajorana operators satisfy the algebra <span class="math display">\[c^2=b_{\gamma}^2=1,\ \ \ \{b_i^\alpha,b_j^\beta \}=\{b_i^\alpha,c_j\}=0.\]</span> In this new basis, we describe a spin by two fermionic modes,i.e., by four Majorana operators. A <spanclass="math inline">\(2\)</span>-dimensional physical space isrepresented by a <span class="math inline">\(4\)</span>-dimensional Fockspace. So we have to impose a constraint <spanclass="math inline">\(D=b_j^xb_j^yb_j^zc_j=1\)</span> at each site. Thisconstraint is much clear in the fermion representation (we assume thatthere are two fermions living on each lattice site) <spanclass="math display">\[f_{i\uparrow}=\frac{b_i^z+ic_i}{2}, \qquadf_{i\downarrow}=\frac{b_i^x+ib_i^y}{2}\]</span> then the constraint operator becomes <spanclass="math display">\[\begin{align}D =1 &amp;=(1-2f_{i\downarrow}^\daggerf_{i\downarrow})(1-2f_{i\uparrow}^\dagger f_{i\uparrow})  \\&amp;= b_j^xb_j^yb_j^zc_j\end{align}\]</span> Therefore, the constraint of fermions means that the singleoccupancies are projected out, only the vacuum and double occupanciesare remained.</p><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Kitaev_representation_majorana_1.png"alt="Representing Spins by Majorana Fermions" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Represent each spin with 2 fermionicmodes. We choose the state with no fermions to be spin up and the statewith two fermions to be spin down. Single occupancies are projected outof the physical Hilbert space by the operator <spanclass="math inline">\(D\)</span>. [2]</em></td></tr></tbody></table><p>The spin space is called <em>physical space</em> and Majorana spaceis called <em>extended space</em>. The operator <spanclass="math inline">\(D\)</span> is used to determine whether any state<span class="math inline">\(|\psi\rangle\)</span> is physical or not.<span class="math inline">\(|\psi\rangle\)</span> is physical <spanclass="math inline">\(\leftrightarrow\)</span> <spanclass="math inline">\(D|\psi\rangle=|\psi\rangle\)</span> (<spanclass="math inline">\(D\)</span> is also called the stabilizer). ThePauli operators <span class="math inline">\(\sigma^{x/y/z}\)</span> inphysical space can be represented by <spanclass="math inline">\(\tilde{\sigma}^\gamma = ib^{\gamma}c\)</span> inMajorana space.</p><h3 id="hamiltonian-in-the-majorana-representation">Hamiltonian in theMajorana representation</h3><p>Each Hamiltonian term <span class="math inline">\(\sigma^\alpha_j\sigma^\alpha_k\)</span> becomes <span class="math display">\[\sigma^\alpha_j \sigma^\alpha_k \to (ib^\alpha_j c_j)(ib^\alpha_k c_k) =-i (ib^\alpha_j b^\alpha_k) c_j c_k.\]</span> here <span class="math inline">\(\hat{u}_{jk}=ib^\alpha_jb^\alpha_k\)</span> is Hermitian, which we associate with the link <spanclass="math inline">\((j,k)\)</span>. Then the Hamiltonian would be<span class="math display">\[H=\frac{i}{4} \sum_{j,k} \hat{A}_{jk} c_j c_k\]</span> with <span class="math inline">\(\hat{A}_{jk} =2J_{\alpha_{jk}}\hat{u}_{jk}\)</span> if <spanclass="math inline">\((j,k)\)</span> are connected and <spanclass="math inline">\(\hat{A}_{jk}=0\)</span> else.</p><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Kitaev_Hamiltonian_in_Majorana.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Graphic representation ofHamiltonian</em>[1]</td></tr></tbody></table><ul><li>the bond operator <spanclass="math inline">\(\hat{u}_{jk}=-\hat{u}_{kj}\)</span>.</li><li>the operator <span class="math inline">\(\hat{u}_{jk}\)</span>commute with the Hamiltonian and with each other: <spanclass="math inline">\([\hat{u}_{ij},\hat{u}_{kl}]=0\)</span>, <spanclass="math inline">\([\hat{u}_{ij},H]=0\)</span>. So the Hilbert spaceis split into common eigenspaces of <spanclass="math inline">\(\hat{u}_{jk}\)</span>, indexed by thecorresponding eigenvalues <span class="math inline">\(u_{jk}=\pm1\)</span>.</li><li>Fixing the eigenvalues <span class="math inline">\(u_{jk}=\pm1\)</span> for each link removes the <spanclass="math inline">\(b\)</span> operators completely from the model.This step reduces the initial spin model to a honeycomb lattice model oftunnelling <span class="math inline">\(c\)</span> Majoranafermions.</li></ul><h3 id="emerging-gauge-field">Emerging gauge field</h3><p>The plaquette operator can be rewritten as <spanclass="math inline">\(W_p=\prod_{\langle ij \rangle \in \partialp}\hat{u}_{ij}\)</span>. These fluxes on the plaquette can be consideredas an artificial magnetic field and <spanclass="math inline">\(u_{ij}\)</span> represents the gauge field,because there are many different sets <spanclass="math inline">\(\{u_{ij}\}\)</span> that give rise to the sameflux sector. Therefore, we identify <spanclass="math inline">\(\hat{u}\)</span> as a <spanclass="math inline">\(Z_2\)</span> gauge field and <spanclass="math inline">\(W_p\)</span> as the associated <spanclass="math inline">\(Z_2\)</span> flux operator (magnetic flux throughthe plaquette <span class="math inline">\(p\)</span>).</p><p>We note that the operators <span class="math inline">\(D_i\)</span>and <span class="math inline">\(\hat{u}_{ij}\)</span> do not commute,which means they don't have the common set of eigenstates. Hence, thesectors labeled by <span class="math inline">\(u_{jk}=\pm 1\)</span> arenot necessarily part of the physical space. Actually, they anti-commutewith each other <span class="math display">\[\{ \hat{u}_{ij}, D_i \} = 0.\]</span> Consequently, the application of the <spanclass="math inline">\(D_i\)</span> operator to an eigenstate of <spanclass="math inline">\(\hat{u}_{ij}\)</span> would invert the sign oflink operators that connected to the site <spanclass="math inline">\(i\)</span>. For an initial state with <spanclass="math inline">\(u_{jk}=+1\)</span> configuration as illustrated inthe following figure, The application of <spanclass="math inline">\(D_i\)</span> does not alter the physical plaquetteoperator <span class="math inline">\(W_p\)</span>, the system remains inthe same vortex sector. In the right side of the figure, we show thattwo vortices are connected by an unphysical string passing through thelink <span class="math inline">\((ij)\)</span> with eigenvalues <spanclass="math inline">\(u_{ij}=-1\)</span>. Due to the anti-commutation of<span class="math inline">\(D_i\)</span> and <spanclass="math inline">\(\hat{u}_{ij}\)</span>, the physical state is anequal amplitude superposition of all loops and strings compatible withthe vortex sector <span class="math inline">\(W\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Kitaev_D_and_u.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>The application of a <spanclass="math inline">\(D_i\)</span> operator at a site. And theunphysical string between two vortices.</em></td></tr></tbody></table><p>The gauge redundancy comes from the representation of the Majoranaoperators, which enlarged the Hilbert space and led to the emergence ofa <span class="math inline">\(Z_2\)</span> gauge field. Therefore, thesystem becomes a form in which non-interacting Majorana fermions arecoupled to the <span class="math inline">\(Z_2\)</span> gauge field, butthe physical properties of the system depend only on the fluxsector.</p><h3 id="diagonalization">Diagonalization</h3><p>We focus on the case where all <spanclass="math inline">\(u_{ij}=+1\)</span>, which corresponds to the<strong>absence of any vortices</strong> (that is the ground state).With a Fourier transformation <span class="math display">\[a_r = \sum_p e^{-i \mathrm{p}\cdot\mathrm{r}} a_p,\]</span> here we use <span class="math inline">\(a\)</span> and <spanclass="math inline">\(b\)</span> to represent the Majorana fermionsplacing on the two sublattice. The Hamiltonian would have the form <spanclass="math display">\[\begin{align}H &amp;= \frac{i}{4} \sum_\mathrm{p} f(\mathrm{p}) a_{-\mathrm{p}}b_\mathrm{p} +h.c. \\&amp;= \frac{i}{4} \sum_\mathrm{p} \left(2J\sum_{\alpha=1,2,3} e^{-i\mathrm{p}\cdot\mathrm{s}_\alpha} \right)  a_{-\mathrm{p}} b_\mathrm{p}+h.c. \\&amp;= \frac{1}{4} \sum_{\mathbf{p}}\left(a_{\mathbf{p}}^{\dagger} \ \ \b_{\mathbf{p}}^{\dagger}\right)\left(\begin{array}{cc}0 &amp; if(\mathbf{p}) \\-if(\mathbf{p})^* &amp; 0\end{array}\right)\left(\begin{array}{l}a_{\mathbf{p}} \\b_{\mathbf{p}}\end{array}\right)\end{align}\]</span> Then the eigenvalues of <spanclass="math inline">\(H(\mathbf{p})\)</span> are given by <spanclass="math display">\[\epsilon(\mathbf{p}) = \pm |f(\mathbf{p})|\]</span></p><p><strong>Another method to diagonalize.</strong> Chen and Nussinovshow that within the ground state sector <spanclass="math inline">\(W_p=\pm 1\)</span>, <spanclass="math inline">\(\forall p\)</span>, the Hamiltonian can be mappedto a 2D <span class="math inline">\(p\)</span>-wave Fermi superfluidwith Hamiltonian <span class="math display">\[\hat{H}=\sum_q \epsilon_q a_q^{\dagger} a_q+\frac{i\Delta_q}{2}\left(a_q^{\dagger} a_{-q}^{\dagger}+\text { H.c. }\right)\]</span> where <span class="math display">\[\begin{aligned}&amp; \epsilon_q \equiv 2 J_z-2 J_z \cos q_x-2 J_y \cos q_y \\&amp; \Delta_q \equiv 2 J_x \sin q_x+2 J_y \sin q_y\end{aligned}\]</span> by the standard BCS procedure, then the quasiparticleexcitation spectrum has the usual form <span class="math display">\[E_q=\sqrt{\epsilon_q^2+\Delta_q^2}\]</span></p><h3 id="ground-state-and-phases">Ground state and phases</h3><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Kitaev_phase_diagram.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Phase diagram</em></td></tr></tbody></table><h3 id="non-abelian-anyons">Non-Abelian Anyons</h3><p>Non-Abelian anyons are defined in terms of their non-trivialevolution under their position exchange. This evolution happens in thedegenerate ground state of the system.</p><table><thead><tr class="header"><th>Honeycomb Lattice</th><th></th><th>Ising Model</th></tr></thead><tbody><tr class="odd"><td>Ground state</td><td><span class="math inline">\(\leftrightarrow\)</span></td><td><span class="math inline">\(1\)</span>, Vaccum</td></tr><tr class="even"><td>Vortex</td><td><span class="math inline">\(\leftrightarrow\)</span></td><td><span class="math inline">\(\sigma\)</span>, Non-Abelian Anyon</td></tr><tr class="odd"><td>Fermionic excitation</td><td><span class="math inline">\(\leftrightarrow\)</span></td><td><span class="math inline">\(\psi\)</span>, Fermion</td></tr></tbody></table><hr /><div id="refer-coupler"></div><ul><li>[1] <ahref="https://www.sciencedirect.com/science/article/abs/pii/S0003491605002381">Kitaev,Alexei. "Anyons in an exactly solved model and beyond." <em>Annals ofPhysics</em> 321.1 (2006): 2-111.</a></li><li>[2] <ahref="https://www.amazon.com/Introduction-Topological-Quantum-Computation-Jiannis/dp/1107005043">JiannisK. Pachos, <em>Introduction to topological quantumcomputation</em></a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;The Kitaev honeycomb model is an exactly solvable model, which
demonstrates the properties of a spin liquid state, specifically the
topological nature and the presence of anyonic excitations. It also has
been proposed as a possible platform for fault-tolerant quantum
computation, due to its topological nature and the presence of anyonic
excitations.</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Topology" scheme="https://quantum-cyborg.github.io/tags/Topology/"/>
    
    <category term="Spin Liquid" scheme="https://quantum-cyborg.github.io/tags/Spin-Liquid/"/>
    
  </entry>
  
  <entry>
    <title>非常简略的笔记：Chern-Simons Field Theory for IQHE</title>
    <link href="https://quantum-cyborg.github.io/2022/11/08/Physics/CS_fileld_theory_IQHE/"/>
    <id>https://quantum-cyborg.github.io/2022/11/08/Physics/CS_fileld_theory_IQHE/</id>
    <published>2022-11-08T11:18:00.000Z</published>
    <updated>2023-12-24T16:18:04.281Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pdf-notes">PDF Notes</h2><span id="more"></span><p><div class="row">    <embed src="CS_fileld_theory_IQHE.pdf" width="100%" height="550" type="application/pdf"></div></p><hr /><h2 id="quantization-of-the-chern-simons-level">Quantization of theChern-Simons level</h2><hr /><p><strong>Large Gauge Transformation.</strong> With gaugetransformation: <span class="math inline">\(A_\mu \to A_\mu +\partial_\mu \omega\)</span>. The electron wave function or fieldtransforms as <spanclass="math inline">\(e^{ie\omega/\hbar}\)</span>.</p><ul><li>Wick rotation: <span class="math inline">\(\tau\)</span> periodic in<span class="math inline">\(\mathbf{S}^1\)</span></li><li>Only physical fields are single valued, <spanclass="math inline">\(\omega(t,x)\)</span> is not need to be singlevalued. Hence, the real requirement is that <spanclass="math inline">\(e^{ie\omega/\hbar}\)</span> is single valued, not<span class="math inline">\(\omega\)</span>.</li></ul><p>Around the circle, setting <span class="math inline">\(\omega =\frac{2\pi\tau}{\beta} \frac{\hbar}{e}\)</span>, leaves the exponential<span class="math inline">\(e^{ie\omega/\hbar}\)</span> singlevalued.</p><ul><li>Large gauge transformation, the name signify that they cannot becontinuously connected to the identity.</li></ul><p>Then the gauge transformation becomes <span class="math display">\[A_0 \to A_0 + \frac{2\pi}{\beta} \frac{\hbar}{e} \]</span> Gaugetranformation does not change the physics, we can think of <spanclass="math inline">\(A_0\)</span> as being a periodic variable, withperiodicity <span class="math inline">\(2\pi\hbar/e\beta\)</span>.</p><hr /><p><strong>Dirac quantization condition | Monopole <spanclass="math inline">\(\mathbf{R}^2 \to\mathbf{S}^2\)</span>.</strong></p><p>We think about the spatial directions as forming a sphere <spanclass="math inline">\(\mathbf{S}^2\)</span>, rather than a plane <spanclass="math inline">\(\mathbf{R}^2\)</span>. By threading a backgroundmagnetic flux through the spatial <spanclass="math inline">\(\mathbf{S}^2\)</span>: <spanclass="math display">\[\frac{1}{2 \pi} \int_{\mathbf{S}^{2}}F_{12}=\frac{\hbar}{e}\]</span> where <spanclass="math inline">\(F_{12}=B_z\)</span>. This is tantamount to placinga Dirac magnetic monopole inside the <spanclass="math inline">\(\mathbf{S}^2\)</span>.</p><ul><li>It's hard to experiment by building a quantum Hall state on asphere.</li></ul><hr /><p><strong>Chern-Simons Term.</strong></p><p><span class="math display">\[S_{C S}=\frac{k}{4 \pi} \int d^{3} xA_{0} F_{12}+A_{1} F_{20}+A_{2} F_{01}\]</span> We can safely set allterms with <span class="math inline">\(\partial_0\)</span> to zero, butintegrating by parts on the spatial derivatives we get an extra factorof 2, <span class="math display">\[S_{C S}=\frac{k}{2 \pi} \int d^{3} xA_{0} F_{12}\]</span> With the gauge potential <spanclass="math inline">\(A_0=a\)</span> and Dirac magnetic monopole, wehave <span class="math display">\[S_{CS}=\beta a \frac{\hbark}{e}\]</span></p><ul><li>Why integrate by parts before evaluating?</li><li>think about the gauge field as being defined locally on differentpatches and glued together</li></ul><hr /><p><strong>Integral Hall Conductivity.</strong> Considering the periodicgauge transformation of <span class="math inline">\(A_0\)</span>, wehave <span class="math display">\[\begin{aligned}S_{c s} &amp;{}\to S_{c s} + \frac{k}{4\pi} \int d^{3} x \cdot\partial_{\mu}\left(\omega \varepsilon^{\mu \nu \rho} \partial_{\nu}A_{\rho}\right) \\&amp;= S_{c s} + \frac{k}{4\pi} \int d\tau d^{3} x \ \nabla\omega \cdot(\nabla \times A)   \\&amp;= S_{c s} + \frac{2\pi k \hbar}{e} \cdot \frac{1}{2\pi}\int_{\mathbf{S}^2} F_{12}  \\&amp;= S_{c s} + \frac{2\pi k \hbar^2}{e^2}\end{aligned}\]</span> It’s ok if the Chern-Simons term itself is not gaugeinvariant, as long as the partition function <spanclass="math inline">\(Z=e^{iS_{CS}/\hbar}\)</span> is, then we shouldhave <span class="math display">\[\frac{k \hbar^2}{e^2} \in \mathbb{Z}\]</span> By writting <span class="math inline">\(k=e^2v/\hbar\)</span>with <span class="math inline">\(v \in \mathbb{Z}\)</span>, the Hallconductivity becomes <span class="math display">\[\sigma_{xy} =\frac{k}{2\pi} = \frac{e^2}{2\pi\hbar}v\]</span> There was no mention ofLandau levels, no mention of whether the charge carriers were fermionsor bosons, or whether they were free or strongly interacting.</p><hr /><p><strong>Remarks.</strong></p><hr /><h2 id="appendix-dirac-quantization-condition">APPENDIX: Diracquantization condition</h2><p>Without magnetic monopoles, <spanclass="math inline">\(q_{m}=0,\)</span>, <spanclass="math inline">\(\nabla \cdot \mathrm{B}=0\)</span>.</p><p>Assume that there is a magnetic monopole with charge <spanclass="math inline">\(q_{m},\)</span> what will happen? The <spanclass="math inline">\(B\)</span> fields is: <spanclass="math display">\[\vec{B}=q_{m} \frac{\vec{e}_{r}}{r^{2}}=q_{m}\frac{\vec{r}}{r^{3}}=q_{m} \frac{(x, y,z)}{\left(x^{2}+y^{2}+z^{2}\right)^{3 / 2}}\]</span> Chosen a vector potential <span class="math display">\[\vec{A}=q_{m} \frac{(y,-x, 0)}{r(r-z)}\]</span> The magnetic field <span class="math display">\[\begin{aligned}\nabla \times \vec{A} &amp;=q_{m} \nabla \times \frac{(y,-x, 0)}{r(r-z)}= q_{m}\left(\partial_{x}, \partial_{y}, \partial_{z}\right) \times\frac{(y,-x, 0)}{r(r-z)}  \\&amp;=q_{m}\left(\partial_{y} \frac{0}{r(r-z)}-\partial_{z}\frac{-x}{r(r-z)}, \partial_{z} \frac{y}{r(r-z)}-\partial_{x}\frac{0}{r(r-z)}, \partial_{x} \frac{-x}{r(r-z)}-\partial_{y}\frac{y}{r(r-z)}\right) \\&amp;=q_{m}\left(-\partial_{z} \frac{-x}{r(r-z)}, \partial_{z}\frac{y}{r(r-z)}, \partial_{x} \frac{-x}{r(r-z)}-\partial_{y}\frac{y}{r(r-z)}\right)\\&amp;=q_{m} \frac{(x, y, z)}{\left(x^{2}+y^{2}+z^{2}\right)^{3 / 2}}\end{aligned}\]</span> It is singular at the north pole <spanclass="math inline">\(z=r\)</span>. In fact, one can prove that nomatter which gauge one uses, there will always be a singularity point. *this singularity is not a physical singularity. All physical observablesare smooth and non-singular functions at this point. * Only A (which isnot a measurable quantity) shows singular behavior. * In addition, thelocation of this singularity point is gauge dependent.</p><hr /><p>So, we can use the first one to describe the south hemisphere and thesecond one to describe the north hemisp <span class="math display">\[\begin{aligned}\overrightarrow{A}_{N} &amp;= q_{m} \frac{(-y, x, 0)}{r(r+z)} \\\overrightarrow{A}_{S} &amp;= q_{m} \frac{(y,-x, 0)}{r(r-z)}\end{aligned}\]</span> At the equator, the vector potential is multivalued (dependingon whether we use <span class="math inline">\(A_{N}\)</span> or <spanclass="math inline">\(A_{S}\)</span> ). The gauge transformation between<span class="math inline">\(A_{N}\)</span> and <spanclass="math inline">\(A_{S}\)</span> is: <span class="math display">\[\overrightarrow{A}_{N} = \overrightarrow{A}_{S} + 2 q_{m} \frac{(-y, x,0)}{(r-z)(r+z)}\]</span> At equator <span class="math inline">\(\mathrm{z}=0\)</span> :<span class="math display">\[\begin{aligned}\overrightarrow{A}_{N} &amp;=\overrightarrow{A_{S}}+2 q_{m} \frac{(-y,x, 0)}{r^{2}} = \overrightarrow{A}_{N}+2 q_{m} \nabla \varphi  \\\vec{A} &amp;{} \rightarrow \vec{A}^{\prime}=\vec{A}+\nabla \Lambda(r,t) \\\Psi(r, t) &amp;{} \rightarrow \Psi^{\prime}(r, t)=\Psi(r, t) \exp\left(i \frac{q_{e}}{c \hbar} \Lambda\right) \\\Phi &amp;{} \rightarrow \Phi^{\prime} =\Phi-\frac{\partial \Lambda(r,t)}{c \partial t} \\\end{aligned}\]</span> Here <span class="math display">\[\begin{aligned}\Lambda(r, t) &amp; =2 q_{m} \varphi \\\Psi_{N}(r, t) &amp;=\Psi_{S}(r, t) \exp \left(i \frac{q_{e}}{c \hbar}\Lambda\right)=\Psi_{S}(r, t) \exp \left[i \frac{2 q_{m} q_{e}}{c \hbar}\varphi\right]\end{aligned}\]</span> Therefore, <span class="math inline">\(2 q_{m} q_{e}/c\hbar\)</span> must be a integral. This tells us that the <em>magneticcharge</em> is quantized: <span class="math display">\[q_{m}=\frac{c \hbar}{2 q_{e}} n\]</span> This is Dirac quantization condition.</p><hr /><ul><li>For a closed surface enclosing a magnetic monopole, no matter whatgauge one uses, the vector potential must have some singularities.</li><li>If <span class="math inline">\(A\)</span> is a non-singular functionon a closed manifold, the magnetic flux through this manifold must bezero.</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;pdf-notes&quot;&gt;PDF Notes&lt;/h2&gt;</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Chern-Simons" scheme="https://quantum-cyborg.github.io/tags/Chern-Simons/"/>
    
  </entry>
  
  <entry>
    <title>超导量子比特：基本知识</title>
    <link href="https://quantum-cyborg.github.io/2022/10/20/Physics/SC%20Qubits%20-%20Basic/"/>
    <id>https://quantum-cyborg.github.io/2022/10/20/Physics/SC%20Qubits%20-%20Basic/</id>
    <published>2022-10-19T16:00:00.000Z</published>
    <updated>2023-12-29T03:36:31.152Z</updated>
    
    <content type="html"><![CDATA[<h2 id="从lc电路到超导量子比特">从LC电路到超导量子比特</h2><p>我们首先考虑如何从经典的LC电路出发来实现量子比特。 <span id="more"></span></p><h3 id="经典lc电路的量子化">经典LC电路的量子化</h3><table><thead><tr class="header"><th style="text-align: center;"><img src="LC_circuit.png"alt="LC 经典电路" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 1. LC 经典电路</em></td></tr></tbody></table><p><em>LC</em>电路最重要的元件是电感和电容，存储在这两个元件上的能量是： <spanclass="math display">\[\begin{align*}\mathcal{H}&amp;=\frac12 CV^2 + \frac12 LI_L^2 \\&amp;= \frac{Q^2}{2C} + \frac{\Phi^2}{2L}.\end{align*}\]</span> 这里<spanclass="math inline">\(C\)</span>是电容，<spanclass="math inline">\(L\)</span>是电感，<spanclass="math inline">\(Q\)</span>是存储在电容上的电荷，而<spanclass="math inline">\(\Phi\)</span>是存储在电感上的磁通量。</p><p>我们知道处在简谐势中的粒子的 Hamiltonian 是 <spanclass="math display">\[H=\frac{p^2}{2m}+\frac{1}{2}m\omega^2x^2\]</span> 我们取如下的对应关系: <spanclass="math inline">\(m=C,p=Q,\Phi=x\)</span> 与 <spanclass="math inline">\(\omega=1/\sqrt{LC}\)</span>，那么这个 Hamiltonian就会完全变成上述经典LC电路的Hamiltonian。因此，我们可以使用类似的量子化方法来对经典的<em>LC</em>电路进行量子化（严格的过程可以从拉格朗日量中慢慢推导出来）。我们首先将<span class="math inline">\(Q\)</span> 与 <spanclass="math inline">\(\Phi\)</span> 变成算符，并且其满足对易关系 <spanclass="math inline">\([\hat{\Phi},\hat{Q}]=i\hbar\)</span>.然后可以定义升降算符 <span class="math display">\[\begin{aligned}\hat{\Phi} &amp;= \sqrt{\frac{\hbar}{2\omega C}}\left(\hat{a}+\hat{a}^{\dagger} \right) \\\hat{Q} &amp;= -i \sqrt{\frac{\hbar \omega C}{2}}\left(\hat{a}-\hat{a}^{\dagger} \right)\end{aligned}\]</span> 于是 <em>LC</em> 电路的 Hamiltonian 就可以简单地表示为 <spanclass="math display">\[\mathcal{H}=\hbar \omega (\hat{a}^{\dagger}\hat{a} + \frac12)\]</span> 其能谱就是间距为 <spanclass="math inline">\(\hbar\omega\)</span> 的等间距能级，如图2.(b)所示</p><table><thead><tr class="header"><th style="text-align: center;"><img src="LC_level.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 2.经典LC电路量子化之后的能谱</em></td></tr></tbody></table><h3 id="构建量子比特">构建量子比特</h3><p>如果只是简单地将经典 <em>LC</em>电路量子化，我们就会发现其能级是等间距的。因此如果我们将能量最低的两个态取做量子比特<span class="math inline">\(|0\rangle\)</span> 与 <spanclass="math inline">\(|1\rangle\)</span>，并且将其耦合起来，实际上这个耦合会将量子比特与更上面的能级<span class="math inline">\(|2\rangle, |3\rangle ...\)</span>也耦合起来，如上图(b)所示，这显然不是我们所希望的。因此，我们需要一种方法将能级给非线性化，使得<span class="math inline">\(|0\rangle\)</span> 与 <spanclass="math inline">\(|1\rangle\)</span> 态之间的能量差 <spanclass="math inline">\(E_{01}\)</span>与其他能级之间的能量差不一样。而使得这一点成为可能的，就是约瑟夫森结。</p><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Josephson_junction.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 3. 约瑟夫森结</em></td></tr></tbody></table><p>约瑟夫森结如上图所示，左右两边各有两块超导体，在其中间加入一块绝缘体将其隔绝开来。中间的薄绝缘体会形成一个势垒，而左右的超导体各自有一个破坏了<span class="math inline">\(U(1)\)</span>对称性的宏观波函数，这两个波函数之间会有微弱的耦合，从而会导致其粒子数与相位发生演化，其演化方程如下所示：<span class="math display">\[\begin{align}I(t) &amp;= I_c \sin(\phi(t)) \\\frac{\rm{d} \phi(t)}{\rm{d} t} &amp;= \frac{2 \pi V(t)}{\Phi_0}\end{align}\]</span> 其中 <spanclass="math inline">\(\phi=\phi_\text{右}-\phi_\text{左}\)</span>是左右波函数的相位之差。根据这两个基本方程，我们就可以得到其中蕴含的能量是<span class="math display">\[\begin{aligned}&amp; \mathcal{U}_J=\int_{-\infty}^t I V d t=I_c \frac{\Phi_0}{2 \pi}\int \sin \phi d \phi \\&amp; =-I_c \frac{\Phi_0}{2 \pi} \cos \phi=-E_J \cos \phi \text {, }\end{aligned}\]</span> 将 <span class="math inline">\(\cos\phi\)</span>做展开，除了二次项之外，会有更高阶的偶次项。而将这些高阶偶次项进行量子化，就可以得到四算符的形式：<span class="math display">\[\begin{aligned}E_J \cos \phi &amp;= 1-\frac{1}{2} E_J \phi^2+\frac{1}{24} E_J\phi^4+\mathcal{O}\left(\phi^6\right) \\\phi^4 &amp;\propto  a^{\dagger} a^{\dagger} a a\end{aligned}\]</span> 这个非线性项，会使得能级不再线性地分布。如上图 (d) 所示，<spanclass="math inline">\(E_{01}\)</span> 与 <spanclass="math inline">\(E_{12},E_{23}.....\)</span>等等完全不相等。这样的话，将最下面的两个态作为量子比特 <spanclass="math inline">\(|0\rangle\)</span> 和 <spanclass="math inline">\(|1\rangle\)</span> 就是安全的。</p><p>其实约瑟夫森结本身具有等效的电容与电感。两个被隔绝的超导体天然就是一个电容。而电感的来源，我们可以从约瑟夫森结的基本方程得到：<span class="math display">\[\frac{d I_J(t)}{dt} = I_0 \cos\phi \frac{2\pi}{\Phi_0} \cdot V(t)\]</span> 所以电感强度就是 <spanclass="math inline">\(L_J=\frac{\Phi_0}{2\pi I_0 \cos\phi}\)</span>.</p><h2 id="三种基本的超导量子比特电路">三种基本的超导量子比特电路</h2><p>由上面的讨论我们知道，一般的超导量子比特电路基本上是由电容、电感、和约瑟夫森结所组成的。其哈密顿量就是由这简单的三项所构成的：<span class="math display">\[H=E_c \hat{n}^2 + E_L \frac{\phi^2}{2}-E_J \cos\phi\]</span>但我们可以对其稍微做一些变形，比如取掉电容或者电感之类的，就可以得到具有不同特性的超导量子比特电路。我们这里简单讨论一下变形所得到的三种典型电路：相位量子比特、电荷量子比特、与磁通量子比特。由于约瑟夫森结的存在，会导致两种能量之间有竞争，一种是约瑟夫森耦合能<span class="math inline">\(E_J=I_c\Phi_0/2\pi\)</span>，另一种是电荷能<span class="math inline">\(E_c=2e^2/C_J\)</span>.以上三种超导量子比特的主要区别就在于约瑟夫森耦合能和电荷能之间的相对大小的不同。</p><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Circuit_Deformation.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 4.超导量子比特电路的变形</em></td></tr></tbody></table><table><thead><tr class="header"><th style="text-align: center;"><img src="three_type_qubit.jpg" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 5.超导量子比特的演变过程</em></td></tr></tbody></table><h3 id="相位量子比特">相位量子比特</h3><p>在上述的 Hamiltonian 中，可以将势能看做： <spanclass="math display">\[U = E_L \frac{\phi^2}{2}-E_J \cos\phi\]</span>我们取中等大小的电感，于是这个势能就相当于是一个抛物线加上一个余弦震荡所产生的坡，如下图所示，这个势能被称作“搓衣板势”。通过适当的参数控制，我们就可以使得某个小势阱中刚好容纳两个能级，这两个能级便可以作为量子比特<span class="math inline">\(|0\rangle\)</span> 与 <spanclass="math inline">\(|1\rangle\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Phase_Qubits.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 6.搓衣板势与相位量子比特</em></td></tr></tbody></table><h3 id="电荷量子比特">电荷量子比特</h3><p>如果我们把电感取到非常大 <span class="math inline">\(L\to\infty\)</span>，也就是将电感替换为开路，如图 4(d)所示。我们可以看到图中的虚线框其实与其他电路是断开的，形成了一个孤立的岛，被称作库伯对岛。这是因为虚线框只能通过约瑟夫森结来与外界交换电荷，而约瑟夫森结中只能流过库伯对，也就是说电荷只能成对地进出这座“孤岛”。而由于电感项被抹去了，只剩下了电容项和约瑟夫森项，哈密顿量就变成了<span class="math display">\[H=E_c(\hat{n}-n_g)^2 - E_J \cos \phi\]</span> 第一项加上了一个<spanclass="math inline">\(n_g\)</span>，代表的是孤岛中库伯对的数量。我们可以通过外加门电压来调节岛上的电荷。由于岛上的电荷是量子化的，可以将其作为量子比特的态，如图7.(c) 所示。</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Charge_Qubits.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 7. 电荷超导量子比特</em></td></tr></tbody></table><h3 id="磁通量子比特">磁通量子比特</h3><p>先看一个超导量子干涉器件(SQUID)，如图 8(a)所示，就是包含一个约瑟夫森结的超导环器件，被称作 rf-SQUID.约瑟夫森结两端具有相位差：<spanclass="math inline">\(\phi/2\pi=\Phi/\Phi_0+z\)</span>, 其中 <spanclass="math inline">\(z\)</span> 是整数，<spanclass="math inline">\(\Phi_0\)</span>是磁通量子。所以超导环的势能可以写作： <span class="math display">\[U=-E_J\cos\frac{2\pi\Phi}{\Phi_0} + E_L(\Phi-\Phi_{ext})^2\]</span> 其中 <span class="math inline">\(\Phi_{ext}\)</span>是外加的磁通。当外加磁通 <spanclass="math inline">\(\Phi_{ext}=\Phi_0/2\)</span> 时，其势能曲线如图8(b) 所示。粒子处于左右两个不同势阱的时候，就对应于 rf-SQUID中的电流顺时针或者逆时针方向流动。因此这两个态就可以用来组成量子比特<span class="math inline">\(|0\rangle\)</span> 和 <spanclass="math inline">\(|1\rangle\)</span>.</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Flux_Qubits.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 8. 磁通量子比特</em></td></tr></tbody></table><h2 id="单比特的操纵">单比特的操纵</h2><p>Transmon量子比特的控制电路如下图所示，右边的线路为<spanclass="math inline">\(XY\)</span>控制线，左边的是<spanclass="math inline">\(Z\)</span>控制线。</p><table><thead><tr class="header"><th style="text-align: center;"><img src="Control_Qubits.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 9. 量子比特的操纵</em></td></tr></tbody></table><p><spanclass="math inline">\(XY\)</span>控制线通过电容与量子比特相连接，并且在线路上施加典型的余弦驱动电流<span class="math inline">\(\Omega\cos(\omega_d t + \phi)\)</span>.由于电容的耦合方式，就会产生如下所示的耦合Hamiltonian <spanclass="math display">\[\hat{H}(t)=-\frac{1}{2} \hbar \omega_{10} \hat{\sigma}_z+\hbar\frac{\Omega}{2}\left(\hat{b}^{\dagger} e^{-i\left(\omega_dt+\phi\right)}+\hat{b} e^{i\left(\omega_d t+\phi\right)}\right)\]</span> 对此哈密顿量做旋波近似，就可以得到 <spanclass="math display">\[\hat{H}=\frac{1}{2} \hbar \delta_q \hat{\sigma}_z+\frac{1}{2} \hbar\Omega\left(\cos \phi \hat{\sigma}_x+\sin \phi \hat{\sigma}_y\right) .\]</span> 通过定义方向矢量 <spanclass="math inline">\(\mathbf{n}=\left(\cos \phi, \sin \phi, \delta_q /\Omega\right)\)</span>, 系统的演化算符就可以写作： <spanclass="math display">\[\hat{U}(\mathbf{n}, t)=e^{-\frac{i \Omega t}{2} \mathbf{n} \cdot\boldsymbol{\sigma}}\]</span> 另一方面，通过对 <span class="math inline">\(Z\)</span>控制线上施加电流来改变其外部磁通<spanclass="math inline">\(\Phi_{ext}\)</span>，就可以调控 <spanclass="math inline">\(\omega_{10}\)</span>.</p><h2 id="两比特之间的耦合">两比特之间的耦合</h2><h3 id="电容电感耦合">电容/电感耦合</h3><table><thead><tr class="header"><th style="text-align: center;"><img src="CL_Qubits_Couple.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 9.两个超导量子比特通过电容或者电感来耦合</em></td></tr></tbody></table><p>超导量子比特之间，或者超导量子比特与谐振腔之间的直接耦合，主要有两种方式：电容耦合或者电感来耦合。如图所示，其Hamiltonian可以写作<span class="math display">\[\begin{aligned}&amp;H=\sum_{i=1,2}\left[4 E_{C, i} n_i^2-E_{J, i} \cos \phi_i\right]+4e^2 \frac{C_g}{C_1 C_2} n_1 n_2 \\&amp;H=\sum_{i=1,2}\left[4 E_{C, i} n_i^2+\frac{1}{2} E_{L, i}\phi_i^2-E_{J, i} \cos \phi_i\right]+M_{12} I_{c 1} \sin \phi_1 I_{c 2}\sin \phi_2\end{aligned}\]</span> Consider the quantized conditions <spanclass="math inline">\(n\propto i(a_i^\dagger - a_i)\)</span> and <spanclass="math inline">\(\phi \propto (a_i^\dagger + a_i)\)</span>, thenthe coupling term can be written as <span class="math display">\[\begin{align}n_1 n_2 &amp;= i(a_1^\dagger - a_1) \cdot i(a_2^\dagger - a_2) \\&amp;\approx a_1^\dagger a_2 + a_1 a_2^\dagger\end{align}\]</span> 最后一步用到了旋波近似。电容所产生的耦合强度一般有<spanclass="math inline">\(g/2\pi \sim20\)</span>MHz，远小于量子比特的频率<spanclass="math inline">\(\omega_1\)</span>与<spanclass="math inline">\(\omega_2\)</span>.对于电感的耦合项也是类似的结果。</p><h3 id="coupler">Coupler</h3><table><thead><tr class="header"><th style="text-align: center;"><img src="coupler.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 10. Coupler</em> [1]</td></tr></tbody></table><p>还有一种操纵性更好的方式是 coupler，将两个超导量子比特 <spanclass="math inline">\(Q_1\)</span> 与 <spanclass="math inline">\(Q_2\)</span>通过中间再加一个量子比特来进行耦合。其哈密顿量可以直接写作 <spanclass="math display">\[\begin{aligned}H &amp; =\sum_{j=1,2} \frac{1}{2} \omega_j \sigma_j^z+\frac{1}{2}\omega_{\mathrm{c}} \sigma_{\mathrm{c}}^z+\sum_{j=1,2}g_j\left(\sigma_j^{+} \sigma_{\mathrm{c}}^{-}+\sigma_j^{-}\sigma_{\mathrm{c}}^{+}\right) \\&amp; +g_{12}\left(\sigma_1^{+} \sigma_2^{-}+\sigma_2^{-}\sigma_1^{+}\right)\end{aligned}\]</span> 可以看到量子比特 <span class="math inline">\(Q_1\)</span> 与<span class="math inline">\(Q_2\)</span>之间有两个耦合通道：一个是量子比特之间直接的长程耦合 <spanclass="math inline">\(g_{12}\)</span>，而另一个通道则是二阶的过程，通过中间量子比特来实现。因此，量子比特<span class="math inline">\(Q_1\)</span> 与 <spanclass="math inline">\(Q_2\)</span> 之间的等效耦合就可以写作： <spanclass="math display">\[\widetilde{H}=\sum_{j=1,2} \frac{1}{2} \widetilde{\omega}_j\sigma_j^z+\left[\frac{g_1 g_2}{\Delta}+g_{12}\right]\left(\sigma_1^{+}\sigma_2^{-}+\sigma_2^{-} \sigma_1^{+}\right)\]</span> 其中 <spanclass="math inline">\(\widetilde{\omega}_j=\omega_j+\frac{g_j^2}{\Delta_j}\)</span>是shift之后的能级。我们可以看到，现在 <spanclass="math inline">\(Q_1\)</span> 与 <spanclass="math inline">\(Q_2\)</span> 之间的等效耦合是 <spanclass="math inline">\(\widetilde{g}=g_1g_2/\Delta +g_{12}\)</span>，因此我们可以通过控制 <spanclass="math inline">\(\Delta\)</span>和这几个耦合强度来调节等效的耦合强度 <spanclass="math inline">\(\widetilde{g}\)</span>，从而可以将 <spanclass="math inline">\(\widetilde{g}\)</span> 调节为正、负、或者零。</p><h2 id="信息读出">信息读出</h2><table><thead><tr class="header"><th style="text-align: center;"><img src="Readout_Qubits.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>图 11.非破坏性测量：色散读取</em></td></tr></tbody></table><p>在超导量子系统中，想要读取量子比特的状态，有一种非破坏性的测量方法，叫做色散读取方法。在这种方法中，用一个光腔与量子比特进行耦合，可以得到一个哈密顿量：<span class="math display">\[H=-\frac{\omega_q}{2} \sigma^z+\omega_r a^{+} a+g\left(\sigma^{+}a+\sigma^{-} a^{+}\right) .\]</span> 其中 <span class="math inline">\(a\)</span>是光子的湮灭算符。考虑失谐 <span class="math inline">\(\Delta\)</span>远大于耦合 <span class="math inline">\(g\)</span>的情况，再做一个幺正变换 <span class="math inline">\(\exp[−g(\sigma+a −\sigma− a^+)/\Delta]\)</span>，就可以得到 <span class="math display">\[H=-\frac{\omega_q}{2} \sigma^z+\left(\omega_r+\frac{g^2}{\Delta}\sigma^z\right) a^{+} a .\]</span>从这个式子中就可以看到，光腔中光子的等效频率是与量子比特的状态相关的。如果量子比特处在<span class="math inline">\(|1\rangle\)</span> 态上，其光波频率就是<span class="math inline">\(\omega_r+\frac{g^2}{\Delta}\)</span>.如果量子比特处在 <span class="math inline">\(|0\rangle\)</span>态上，其光波频率就是 <spanclass="math inline">\(\omega_r-\frac{g^2}{\Delta}\)</span>.因此通过对光波频率的测量，就可以非破坏性地知道量子比特的状态。</p><h2 id="量子模拟">量子模拟</h2><table><thead><tr class="header"><th style="text-align: center;"><imgsrc="Quantum_Simulation.png" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Figure 12. Analogue simulation anddigital simulation</em></td></tr></tbody></table><p>Analogue Simulation</p><ul><li>缺点:<ul><li>只能实现特定的模型，</li><li>没有错误编码和修正，而错误又是不可避免的。参数的矫正可能会有问题，实现的Hamiltonian也会不完美，还有退相干和噪音的干扰。</li></ul></li></ul><hr /><div id="refer-coupler"></div><ul><li>[1] <ahref="https://journals.aps.org/prapplied/abstract/10.1103/PhysRevApplied.10.054062">Yan,Fei, et al. "Tunable coupling scheme for implementing high-fidelitytwo-qubit gates." <em>Physical Review Applied</em> 10.5 (2018):054062.</a></li><li>[2] <ahref="">刘伟洋,于海峰,薛光明等.超导量子比特与量子计算[J].物理教学,2013,35(07):2-5.</a></li><li>[3] <ahref="">董宁,王轶文,于扬等.超导量子比特的物理实现[J].自然科学进展,2008(07):721-726.</a></li><li>[4] <ahref="">宿非凡,杨钊华,范桁等.超导量子比特[J].大学物理,2021,40(07):1-7+11.DOI:10.16854/j.cnki.1000-0712.210045.</a></li><li>[5] <a href="">徐达.基于超导量子比特的量子模拟[D].浙江大学,2018.</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;从lc电路到超导量子比特&quot;&gt;从LC电路到超导量子比特&lt;/h2&gt;
&lt;p&gt;我们首先考虑如何从经典的LC电路出发来实现量子比特。</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Quantum Computing" scheme="https://quantum-cyborg.github.io/tags/Quantum-Computing/"/>
    
    <category term="Superconducting Quantum Qubits" scheme="https://quantum-cyborg.github.io/tags/Superconducting-Quantum-Qubits/"/>
    
  </entry>
  
  <entry>
    <title>Stabilizer Codes (I)</title>
    <link href="https://quantum-cyborg.github.io/2022/10/11/Physics/Stabilizer-codes/"/>
    <id>https://quantum-cyborg.github.io/2022/10/11/Physics/Stabilizer-codes/</id>
    <published>2022-10-10T16:00:00.000Z</published>
    <updated>2024-01-02T07:27:27.802Z</updated>
    
    <content type="html"><![CDATA[<p>Stabilizer codes were developed to correct the errors that occur inmany qubit systems. <span id="more"></span></p><h2 id="pauli-group">Pauli Group</h2><p>On <span class="math inline">\(1\)</span> qubit the Pauli group <spanclass="math inline">\(G_1\)</span> is defined as</p><p><span class="math display">\[G_1 \equiv \left\{ \pm I, \pm iI, \pm X, \pm i X, \pm Y, \pm i Y, \pm Z,\pm i Z \right\}\]</span> which is generated by the products of Pauli matrices with thefactors <span class="math inline">\(\pm1\)</span> and <spanclass="math inline">\(\pm i\)</span>. These matrices form a group underthe operation of matrix multiplication. The factors <spanclass="math inline">\(\pm1\)</span> and <span class="math inline">\(\pmi\)</span> are included to ensure that <spanclass="math inline">\(G_1\)</span> is closed under multiplication.</p><p>On <span class="math inline">\(n\)</span> qubits, the Pauli group<span class="math inline">\(G_n\)</span> is defined as <spanclass="math display">\[G_n \equiv \left\{ i^k \prod_n X_n^{a_n} Z_n^{b_n} \right\}\]</span> here <span class="math inline">\(k\)</span>, <spanclass="math inline">\(a_n\)</span> and <spanclass="math inline">\(b_n\)</span> are all arbitrary integers.Therefore, the group <span class="math inline">\(G_n\)</span> consistsof all <span class="math inline">\(n\)</span>-fold tensor products ofPauli matrices, with the factors <span class="math inline">\(\pm1\)</span> or <span class="math inline">\(\pm i\)</span>.</p><h2 id="stabilizer">Stabilizer</h2><p><strong>Definition.</strong> Suppose <spanclass="math inline">\(S\)</span> is a subgroup of <spanclass="math inline">\(G_n\)</span>, define <spanclass="math inline">\(V_S\)</span> to be the vector space <spanclass="math display">\[V_S = \left\{ |\psi\rangle \ | \ \hat{g}|\psi\rangle = |\psi\rangle,\quad \forall \hat{g} \in S  \right\}\]</span> We say that an operator <em>fixes</em> the state if the stateis an eigenket with eigenvalue <span class="math inline">\(+1\)</span>for this operator. So we call <span class="math inline">\(V_S\)</span>the <em>vector space stabilized by <spanclass="math inline">\(S\)</span></em>, and <spanclass="math inline">\(S\)</span> is said to be the <em>stabilizer</em>of the space <span class="math inline">\(V_S\)</span>.</p><p><strong>Non-trivial <spanclass="math inline">\(V_S\)</span>.</strong> The conditions to constructa non-trivial <span class="math inline">\(V_S\)</span> (at leastcontains a non-zero vector) :</p><ul><li><span class="math inline">\(-I\)</span> should not be an element of<span class="math inline">\(S\)</span>, because the only solution to<span class="math inline">\((-I)|\psi\rangle=|\psi\rangle\)</span> is<span class="math inline">\(|\psi\rangle=0\)</span>.</li><li>The elements of <span class="math inline">\(S\)</span> should becommute with each other. The Pauli matrices all commute or anti-commutewith one another. If the elements <span class="math inline">\(M\)</span>and <span class="math inline">\(N\)</span> of <spanclass="math inline">\(S\)</span> anti-commute, then we have <spanclass="math inline">\(-NM=MN\)</span> and <spanclass="math inline">\(MN|\psi\rangle = |\psi\rangle=-NM|\psi\rangle=-|\psi\rangle\)</span>, which implies that <spanclass="math inline">\(|\psi\rangle\)</span> is the zero vector.</li></ul><p><strong>Properties of stabilizer.</strong></p><ul><li><span class="math inline">\(S\)</span> is an Abelian group, becauseall the elements <span class="math inline">\(\hat{g}\)</span> commutewith each other.</li><li></li></ul><p><strong>Example 1.</strong> The Bell state can be written as <spanclass="math inline">\(|\psi\rangle=(|00\rangle+|11\rangle)/\sqrt2\)</span>. It can be easily shown that <spanclass="math inline">\(X_1X_2|\psi\rangle=|\psi\rangle\)</span> and <spanclass="math inline">\(Z_1Z_2 |\psi\rangle=|\psi\rangle\)</span>.Therefore the Bell state is stabilized by <spanclass="math inline">\(S=\left\{ X_1X_2,Z_1Z_2 \right\}\)</span>.</p><p><strong>Example 2.</strong> We show a simple example with <spanclass="math inline">\(n=3\)</span> qubits, the stabilizer is taken as<span class="math display">\[S \equiv \left\{ I, Z_1Z_2, Z_2Z_3, Z_1Z_3\right\}\]</span> * The subspace fixed by <spanclass="math inline">\(Z_1Z_2\)</span> is spanned by <spanclass="math inline">\(|000\rangle\)</span>, <spanclass="math inline">\(|001\rangle\)</span> <spanclass="math inline">\(|110\rangle\)</span> and <spanclass="math inline">\(|111\rangle\)</span>. * The subspace fixed by<span class="math inline">\(Z_2Z_3\)</span> is spanned by <spanclass="math inline">\(|000\rangle\)</span>, <spanclass="math inline">\(|100\rangle\)</span> <spanclass="math inline">\(|011\rangle\)</span> and <spanclass="math inline">\(|111\rangle\)</span>. * The subspace fixed by<span class="math inline">\(Z_1Z_3\)</span> is spanned by <spanclass="math inline">\(|000\rangle\)</span>, <spanclass="math inline">\(|010\rangle\)</span> <spanclass="math inline">\(|101\rangle\)</span> and <spanclass="math inline">\(|111\rangle\)</span>. Note that the elements <spanclass="math inline">\(|000\rangle\)</span> and <spanclass="math inline">\(|111\rangle\)</span> are common to both theselists. So <span class="math inline">\(V_S\)</span> is the subspacespanned by the states <span class="math inline">\(|000\rangle\)</span>and <span class="math inline">\(|111\rangle\)</span>. Actually, thegenerators of this group is <span class="math inline">\(S=\langleZ_1Z_2,Z_2Z_3 \rangle\)</span> because <spanclass="math inline">\(Z_1Z_3=(Z_1Z_2)(Z_2Z_3)\)</span> and <spanclass="math inline">\(I=(Z_1Z_2)^2\)</span>. ()</p><ul><li>Actually, many quantum states can be more easily described by theoperators (stabilizer code) than the state itself.</li></ul><h2 id="surface-code">Surface Code</h2><p>The surface codes are a family of quantum error correcting codesdefined on a 2D lattice of qubits. The members of the surface codefamily are sometimes also described by more specific names: The toriccode is a surface code with periodic boundary conditions, the planarcode is one defined on a plane, etc. The term ‘surface code’ issometimes also used interchangeably with ‘planar code’, since this isthe most realistic example of the surface code family.</p><h3 id="toric-code">Toric code</h3><table><thead><tr class="header"><th style="text-align: center;"><img src="toric_code.png"alt="toric code" /></th></tr></thead><tbody><tr class="odd"><td style="text-align: center;"><em>Toric code Hamiltonian</em></td></tr></tbody></table><p>The toric code is a topological quantum error correcting code, and anexample of a stabilizer code, which is proposed by Kitaev. Consider aset of spin-<span class="math inline">\(1/2\)</span> "spins" on themiddle of the links of a square lattice, with the Hamiltonian <spanclass="math display">\[H_\text{TC} = -K\sum_v A_v - K&#39; \sum_p B_p\]</span> where the sums are over plaquettes <spanclass="math inline">\(p\)</span> and vertex <spanclass="math inline">\(v\)</span>. The plaquette operator <spanclass="math inline">\(B_p=\prod_{i\in p} \sigma_i^z\)</span> is aproduct over the spins on the bonds surrounding the plaquette <spanclass="math inline">\(p\)</span>, and the “star” operator <spanclass="math inline">\(A_p=\prod_{i\in v} \sigma_i^x\)</span> is aproduct over the spins on bonds neighboring the vertex <spanclass="math inline">\(v\)</span>, as shown in the above figure.</p><ul><li>All the <span class="math inline">\(A\)</span> and <spanclass="math inline">\(B\)</span> operators commute with each other. Sothe ground states are simply those states for which <spanclass="math inline">\(A_v = B_p = +1\)</span> for every star andplaquette.</li><li>Topological degeneracy: For a lattice of <spanclass="math inline">\(N\)</span> sites with periodic boundaryconditions, there are <span class="math inline">\(N-1\)</span>independent choices of star eigenvalues, and <spanclass="math inline">\(N − 1\)</span> independent choices of plaquetteeigenvalues. Consequently, there are <spanclass="math inline">\(2^{2N−2}\)</span> specifications of eigenvalues,but there are a total of <span class="math inline">\(2^{2N}\)</span>spin states. So each particular choice of <spanclass="math inline">\(\{A_v,B_p\}\)</span> is four-fold degenerate onthe torus.</li></ul><p>Then we discuss how this toric code model is related to thestabilizer. * Codespace: We know the ground state <spanclass="math inline">\(|G\rangle\)</span> satisfies <spanclass="math display">\[\forall v,\ A_v|G\rangle=+|G\rangle,\qquad \forall p,\B_p|G\rangle=+|G\rangle.\]</span> This defines the codespace of the code. The <spanclass="math inline">\(N^2\)</span> terms <spanclass="math inline">\(A_v\)</span> and <spanclass="math inline">\(B_p\)</span> are refered as stabilizers. Thestabilizers define the ground states that have a Hilbert space ofdimension <span class="math inline">\(4\)</span>, then this system couldencode two qubits. * Logical qubit : * Pauli matries act on logicalqubit :</p><h3 id="the-planar-code">The Planar Code</h3><p>The details are basically identical to the Toric code, except thatthe boundary conditions of the lattice are <strong>open</strong> insteadof periodic. This means that the stabilizers at the edges are definedslightly differently. In this case, there is only one logical qubit inthe code instead of two.</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Stabilizer codes were developed to correct the errors that occur in
many qubit systems.</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Quantum Computing" scheme="https://quantum-cyborg.github.io/tags/Quantum-Computing/"/>
    
  </entry>
  
  <entry>
    <title>辛几何随笔</title>
    <link href="https://quantum-cyborg.github.io/2022/02/09/Math/Symplectic/"/>
    <id>https://quantum-cyborg.github.io/2022/02/09/Math/Symplectic/</id>
    <published>2022-02-09T03:33:53.000Z</published>
    <updated>2023-12-24T16:21:33.252Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个玻色理论的拉氏量仅仅包含时间的一次导数的话，比如Chern-Simons理论，那么在正则量子化的过程中，我们会发现广义动量实际上和广义坐标相重合了，那么相空间实际上就是坐标空间，并且在考虑量子化之后，相空间会变成一个非对易几何。具体地说，考虑如下一个作用量：<span id="more"></span><span class="math display">\[S = \int d t \lambda_i (\phi) \frac{d\phi^i}{d t},\]</span> 其中<spanclass="math inline">\(\phi^i\)</span>是广义坐标，正则动量实际上正是<spanclass="math inline">\(\lambda_i(\phi)\)</span>并且是<spanclass="math inline">\(\phi^i\)</span>的一个函数，因此相空间和坐标空间实际上是相同的。在相空间上我们可以找到一个非退化（处处非零）的2-形式场，对作用量进行变分可以得到：<span class="math display">\[\delta S = \int d t (\partial_i \lambda_j -\partial_j \lambda_i ) \delta \phi^i \frac{d \phi^j}{d t},\]</span>如果作用量是非退化的，那么我们就可以得到一个非退化的2-形式场： <spanclass="math display">\[\omega = (\partial_i \lambda_j - \partial_j\lambda_i ) d\phi^i \wedge d \phi^j,\]</span>我们称之为相空间上的辛形式。</p><p>在这里我们介绍一下辛几何相关的内容，我们可以想像成是物理里面的相空间。对于一个辛流形，我们有一个非退化（处处非零）的闭2-形式场：<span class="math display">\[\omega = \frac{1}{2} \omega_{\mu \nu} dx^{\mu} d x^{\nu},\]</span> 其中<span class="math inline">\(\mu =1,\cdots ,2n\)</span>，<spanclass="math inline">\(n\)</span>是流行的维度，我们称<spanclass="math inline">\(\omega\)</span>为流形上的辛形式。利用辛形式我们可以定义柏松括号，也就是对于辛流形（相空间）上的任何两个函数<spanclass="math inline">\(f_1,f_2\)</span>，我们有： <spanclass="math display">\[\{ f_1 , f_2 \} = \omega^{\mu \nu} \frac{\partialf_1}{\partial x^{\mu}}\frac{\partial f_2}{\partial x^{\nu}},\]</span>其中上指标的<span class="math inline">\(\omega^{\mu\nu}\)</span>是辛形式的逆。在辛流形（相空间）上，对于一个局域的坐标片，我们都可以将辛形式写为标准形式，也就是可以选取一组局域坐标<spanclass="math inline">\((p_i,q^i)\)</span>使得： <spanclass="math display">\[\omega = \sum_{i=1}^{n} d p_i \wedge dq^i.\]</span></p><h1 id="动量映射moment-map">动量映射（Moment map）</h1><p>通常在经典力学里面，给定一个对称性我们可以得到相应的守恒量，比如平移和转动分别对应的是动量和角动量。动量映射是两者在辛流形（相空间）上面的一个推广。</p><p>令<spanclass="math inline">\((M,\omega)\)</span>为一个相空间，回忆起给定相空间上的任意一个函数<spanclass="math inline">\(h\)</span>我们可以构造一个所谓的哈密顿矢量场 <spanclass="math inline">\(V\)</span> 使得 <spanclass="math inline">\(\iota(V) \omega = d h\)</span>： <spanclass="math display">\[V(h)^i = \omega^{ij} \partial_j h,\]</span>其中<spanclass="math inline">\(\iota\)</span>是缩并算符。这个矢量场生成的微分同胚变换是保持辛形式不变的：<span class="math display">\[\begin{aligned}    \mathcal{L}_{V} \omega &amp;= (d \iota (V) + \iota(V) d) \omega\nonumber \\    &amp;= d \iota(V) \omega \nonumber \\    &amp;= d (V^i \omega_{ij} dx^j) \nonumber \\    &amp;= d (\omega^{ik} \omega_{ij} \partial_k h d x^j) \nonumber \\    &amp;= d^2 h = 0.\end{aligned}\]</span>实际上正则变换的生成母函数就是上述的例子，它对应的矢量场生成的正是正则变换。再继续之前我们先提及一些柏松括号以及哈密顿矢量场的性质，如果我们给定两个函数<spanclass="math inline">\(f,g\)</span>，我们有 <spanclass="math display">\[\begin{aligned}    \{ f , g \} &amp;= \omega^{ij} \frac{\partial f}{\partialx^{i}}\frac{\partial g}{\partial x^{j}}   \nonumber \\    &amp;= \frac{\partial f}{\partial x^{i}} V(g)^{i} \nonumber \\    &amp;=\mathcal{L}_{V(g)} f,\end{aligned}\]</span>进一步地，我们还可以有： <span class="math display">\[\begin{aligned}    \{ f , g \} &amp;= \omega^{ij} \frac{\partial f}{\partialx^{i}}\frac{\partial g}{\partial x^{j}}   \nonumber \\    &amp;= \frac{\partial f}{\partial x^{i}} V(g)^{i} \nonumber \\    &amp;=-\omega_{ik} \omega^{kj}\frac{\partial f}{\partial x^{j}}V(f)^{i}\nonumber \\    &amp;= \omega_{ij} V(f)^i V(g)^j \nonumber \\    &amp; \equiv \omega(V(f),V(g)).\end{aligned}\]</span> 函数<spanclass="math inline">\(f,g\)</span>的柏松括号定义了一个新的函数，我们也可以求出它的哈密顿矢量场，其结果为：<span class="math display">\[\begin{aligned}    V(\{f,g\}) = - [V(f) , V(g)],\end{aligned}\]</span>其中后者为两个矢量场之间的李括号。</p><p>接下来，如果有一个作用在流形<spanclass="math inline">\(M\)</span>上的李群<spanclass="math inline">\(G\)</span>，它保持辛形式不变： <spanclass="math display">\[g^* (\omega) = \omega,\quad \forall g \inG,\]</span> 那么如果<span class="math inline">\(T\in\mathbf{g}\)</span>是一个生成元，由它生成的无穷小变换的切矢量场记为<spanclass="math inline">\(\xi=\xi(T)\)</span>，那么我们有： <spanclass="math display">\[\mathcal{L}_{\xi} \omega = (d \iota(\xi) + \iota(\xi) d) \omega = d (\iota(\xi) \omega) =0,\]</span>因此如果我们假定<spanclass="math inline">\(H^1_{DR}(M)=0\)</span>的话，那么我们可以令： <spanclass="math display">\[\iota(\xi) \omega = d \mu,\]</span> 其中<spanclass="math inline">\(\mu\)</span>是流形<spanclass="math inline">\(M\)</span>上的一个全局定义的函数。实际上由上述构造我们可以看出，这个函数是依赖于生成元<spanclass="math inline">\(T\)</span>的，我们记为<spanclass="math inline">\(\mu(p;T)\)</span>，其中<spanclass="math inline">\(p\)</span>是流形<spanclass="math inline">\(M\)</span>上的坐标。在哈密顿体系里面，这个<spanclass="math inline">\(\mu\)</span>实际上正是上述生成元<spanclass="math inline">\(T\)</span>对称性的守恒荷，对于任何一个函数<spanclass="math inline">\(f\)</span>，利用柏松括号我们可以得到： <spanclass="math display">\[\begin{aligned}    \{ \mu , f \} &amp;= \omega^{ij} \partial_i \mu \partial_j f\nonumber \\    &amp;= \omega^{ij} \xi^k \omega_ki \partial_j f \nonumber \\    &amp;= \xi^i \partial_i f \nonumber \\    &amp;= \mathcal{L}_{\xi} (f),\end{aligned}\]</span>因此最后我们得到了<span class="math inline">\(f\)</span>沿着<spanclass="math inline">\(\xi(T)\)</span>方向的李导数。</p><p>给定流形上任意一点<span class="math inline">\(p\)</span>，守恒荷<spanclass="math inline">\(\mu(p,\cdot)\)</span>可以看作是从李代数<spanclass="math inline">\(\mathbf{g}\)</span>到实数的一个映射，并且由于<spanclass="math inline">\(T \rightarrow\xi(T)\)</span>是一个线性映射，因此<spanclass="math inline">\(\mu(p,\cdot)\)</span>同样是一个线性映射，从这种角度，我们可以认为<spanclass="math inline">\(\mu\)</span>是一个流形<spanclass="math inline">\(M\)</span>到对偶李代数<spanclass="math inline">\(\mathbf{g}^*\)</span>的一个映射： <spanclass="math display">\[\mu : M \rightarrow \mathbf{g}^*,\]</span>这个映射我们就称之为动量映射。由定义，它满足： <spanclass="math display">\[\langle T , \mu(p) \rangle =\mu(p,T).\]</span></p><p>接下来考虑一个最简单的例子，来看一下动量映射是怎么对应到动量和角动量上去的。考虑<spanclass="math inline">\(n\)</span>维欧式空间<spanclass="math inline">\(\mathbb{R}^n\)</span>以及它的余切空间（余切丛）<spanclass="math inline">\(T^*\mathbb{R}^n\)</span>，选取一组广义坐标和广义动量<spanclass="math inline">\((\vec{q},\vec{p}) =(q^i,p_j)\)</span>，那么余切丛上的辛形式为： <spanclass="math display">\[\omega = \sum_i d p_i \wedge d q^i.\]</span>接下来我们考虑庞加莱群<spanclass="math inline">\(\mathbb{P}^n\)</span>对流形<spanclass="math inline">\(\mathbb{R}^n\)</span>的作用。首先是平移群<spanclass="math inline">\(\mathbb{R}^n\)</span>的作用，选择任意一个平移矢量<spanclass="math inline">\(\vec{a}\)</span>，我们有： <spanclass="math display">\[\vec{a}\cdot (\vec{q},\vec{p}) =(\vec{q}+\vec{a},\vec{p}).\]</span> 平移群的李代数仍然为<spanclass="math inline">\(\mathbb{R}^n\)</span>，选取李代数中的一个单位矢量<spanclass="math inline">\(\vec{v}\)</span>代表平移的方向，那么它生成的无穷小变换的切矢量可以写为：<span class="math display">\[\xi(\vec{v}) = v^i \frac{\partial}{\partialq^i},\]</span> 从而有： <span class="math display">\[\iota(\xi(\vec{v})) \omega = -v^i d p_i = d \mu(q^i,p_i;\vec{v}) ,\]</span>其中动量映射<spanclass="math inline">\(\mu(q^i,p_i;\vec{v})\)</span>为： <spanclass="math display">\[\mu(q^i,p_i;\vec{v}) = -v^i p_i,\]</span>这也正是<span class="math inline">\(\vec{v}\)</span>方向的动量。</p><p>随后我们再考虑转动群，不过在那之前，我们不妨先考虑一个一般线性变换。令考虑偶数维相空间<spanclass="math inline">\(V_{2n} =\{(x^1,\cdots,x^{2n}\}\)</span>，李群<spanclass="math inline">\(G\)</span>作用是<spanclass="math inline">\(V_{2n}\)</span>上保持辛形式不变的一个线性对称变换，坐标按照李群<spanclass="math inline">\(G\)</span>的某种矩阵表示来进行变换。令<spanclass="math inline">\(T^A\)</span>为李代数，记<spanclass="math inline">\(\rho(T^A)^i_{\ j}\)</span>为<spanclass="math inline">\(N\timesN\)</span>的矩阵表示，并且无穷小变换对应的切矢量场为： <spanclass="math display">\[\xi(T^A) = x^j \rho(T^A)^i_{\ j}\frac{\partial}{\partial x^i},\]</span> 那么接下来有： <spanclass="math display">\[\iota(\xi) \omega =  x^j \rho(T^A)^i_{\ j}\omega_{ik} d x^k = d \left(\frac{1}{2}x^j \rho(T^A)^i_{\ j}\omega_{ik}x^k \right)\]</span> 我们可以读出动量映射为: <spanclass="math display">\[\mu^A (x,T^A) = \frac{1}{2}x^j \rho(T^A)^i_{\ j}\omega_{ik}x^k .\]</span></p><p>最后对于<spanclass="math inline">\(\mathbb{R}^n\)</span>上的转动变换。不失一般性，我们就考虑<spanclass="math inline">\(1-2\)</span>平面上的转动，也就是对于广义坐标<spanclass="math inline">\(q\)</span>我们有无穷小变换<spanclass="math inline">\(g(t)\)</span>： <span class="math display">\[q^1\rightarrow q^1 + t q^2,\quad q^2 \rightarrow q^2 - t q^1,\]</span>因为<spanclass="math inline">\(\vec{p}\)</span>是余切矢量，因此它的变换为： <spanclass="math display">\[p_1 \rightarrow p_1 - t p_2,\quad p_2 \rightarrowp_2 + t p_1,\]</span>这样辛形式在上述变换下保持不变。因此我们可以读出无穷小变换为： <spanclass="math display">\[\xi = q^2 \frac{\partial}{\partial q^1} - q^1\frac{\partial}{\partial q^2} - p_2 \frac{\partial}{\partial p_1}+ p_1\frac{\partial}{\partial p_2},\]</span> 因此由： <spanclass="math display">\[\iota(\xi) \omega = -p_2 d q^1 + p_1 dq^2 -q^2dp_1 + q^1 dp_2 = d (q^1p_2 - q^2 p_1),\]</span> 因此动量映射为： <spanclass="math display">\[\mu(q,p,1-2) = q^1p_2 - q^2p_1,\]</span>实际上就是<span class="math inline">\(1-2\)</span>平面上的角动量。</p><h1 id="哈密顿约化">哈密顿约化</h1><p>有些时候，我们研究的系统会存在一些约束，比如某些守恒量是一个固定值。我们已经看到系统的守恒量使用动量映射函数<spanclass="math inline">\(\mu(x,T)\)</span>来表示，因此我们需要考虑下述形式的约束条件：<span class="math display">\[\phi^A = \mu(T^A) - \langle T^A , \xi\rangle = 0,\]</span>我们称之为第一类约束条件。这个条件给出了相空间中的一个曲面<spanclass="math inline">\(S\)</span>： <span class="math display">\[S = \{p| \phi^A(p) = 0\}.\]</span> 如果我们假定 <spanclass="math display">\[\{ \mu^A , \mu^B \} = f_{^{AB}_{\quad C}}\mu^C,\]</span> 那么可以证明上述曲面在李群<spanclass="math inline">\(G\)</span>的作用下是保持不变的，因此我们可以考虑下述哈密顿约化：<span class="math display">\[M //_{\zeta} G = \mu^{-1}(\zeta) /G.\]</span> 哈密顿约化在系统的量子化中有重要的作用。</p><p>这里我们进一步考虑一种特殊情况，即相空间是一个凯勒（K<spanclass="math inline">\(\ddot{\textrm{a}}\)</span>hler）流形。凯勒流形有一个和度规适配的复结构张量<spanclass="math inline">\(I\)</span>满足： <spanclass="math display">\[g(IX,IY) = g(X,Y),\quad X,Y \in TM,\]</span>并且是平移不变的：<span class="math inline">\(\nabla I =0\)</span>。对于凯勒流形而言，它的辛形式可以由度规定义为：<spanclass="math inline">\(\omega(X,Y) = g(X,IY)\)</span>，或者写为： <spanclass="math display">\[\omega = \frac{i}{2} g_{i \bar{j}} d z^i \wedge d\bar{z}^{\bar{j}},\]</span> 其中度规为<span class="math inline">\(d s^2= g_{i \bar{j}} d z^i d \bar{z}^{\bar{j}} + c.c\)</span>。辛形式<spanclass="math inline">\(\omega\)</span>通常也被称作为凯勒形式。</p><p>如果<spanclass="math inline">\(M\)</span>是一个凯勒流形的话，有定理保证上述保持辛形式不变的作用<spanclass="math inline">\(G\)</span>实际上没有固定点，并且商空间<spanclass="math inline">\(M//G\)</span>同样为一个凯勒流形，它的凯勒结构继承自<spanclass="math inline">\(M\)</span>。</p><p>一个重要的例子就是<span class="math inline">\(N\)</span>维复空间<spanclass="math inline">\(V=\mathbb{C}^N\)</span>，其上的凯勒形式可以自然地写为：<span class="math display">\[\omega = \frac{i}{2} \sum_{a=1}^N d z^a\wedge d \bar{z}_a = \sum_a d x^a \wedge d y^a,\]</span>其中复坐标定义为：<span class="math inline">\(z^a = x^a + iy^a\)</span>。显而易见，任意一个幺正变换<spanclass="math inline">\(U(N)\)</span>作用于复坐标<spanclass="math inline">\(z^a\)</span>，凯勒形式和度规都是保持不变的，因此我们可以求出上述幺正变换对应的动量映射。<spanclass="math inline">\(U(N)\)</span>对应的李代数可以写为<spanclass="math inline">\(N\times N\)</span>维的反厄米矩阵： <spanclass="math display">\[(T^a_{\ b})^* = - T^b_{\ a},\]</span>因此对应的无穷小变换可以写为： <span class="math display">\[\xi(T) = z^bT^a_{\ b} \frac{\partial}{\partial z^a} - \bar{z}_a T^b_{\ a}\frac{\partial}{\partial \bar{z}^a},\]</span>因此我们可以求得相应的动量映射为： <span class="math display">\[\mu(T) =i z^b T^a_{\ b} \bar{z}_a.\]</span></p><p>特别地，我们我们考虑一个<spanclass="math inline">\(U(1)\)</span>转动： <spanclass="math display">\[e^{i\theta} : z^a \rightarrow e^{i Q^a \theta}z^a, \quad a=1,\cdots,N,\]</span> 相应的动量映射为： <spanclass="math display">\[\mu = \sum Q^a |z^a|^2,\]</span> 其中<spanclass="math inline">\(Q^a\)</span>为整数。如果对超对称理论足够熟悉的话，那么上述动量映射实际上就是所谓的<spanclass="math inline">\(D\)</span>-term势能项。考虑4维<spanclass="math inline">\(\mathcal{N}=1\)</span>的一个超对称U(1)规范理论，理论中有<spanclass="math inline">\(N\)</span>组hypermultiplet，它们所携带的U(1)荷为<spanclass="math inline">\(Q^a\)</span>。那么如果我们把矢量超场中的辅助场<spanclass="math inline">\(D\)</span>积分积掉之后，那么便会给出一个势能项：<span class="math display">\[V = \frac{1}{2} D^2 = \frac{1}{2}\left(\sum_{a=1}^N Q^a |\Phi^a|^2\right)^2,\]</span> 其中<spanclass="math inline">\(\Phi^a\)</span>是hypermultiplet里面的复标量场，这个其实就是<spanclass="math inline">\(\Phi^a\)</span>所构成的理论模空间的U(1)对称性所生成的动量映射。特别地，我们还可以考虑加入所谓的Fayet--Iliopoulos<span class="math inline">\(D\)</span>-term： <spanclass="math display">\[S_{\textrm{FI}} = \xi \int d^4 x d^4 \theta V =\xi \int d^4 x D,\]</span> 其中<spanclass="math inline">\(V\)</span>是U(1)的矢量超场，D则是上述辅助场。那么这项实际上会使得势能项有一个偏移：<span class="math display">\[V = \frac{1}{2} D^2 =\frac{1}{2}\left(\sum_{a=1}^N Q^a |\Phi^a|^2 - \xi \right)^2,\]</span>如果我们考虑理论的真空的话，它实际上就是<spanclass="math inline">\(\Phi^a\)</span>所构成的理论模空间中的一个约化曲面。</p><h1 id="相空间量子化">相空间量子化</h1><p>首先我们需要说明的是，什么是相空间量子化？我们考虑一个辛流形<spanclass="math inline">\(\mathcal{P}\)</span>，其上有一个处处不为零的闭的辛形式<spanclass="math inline">\(\omega = \frac{1}{2} \omega_{ij}(x) d x^i \wedge dx^j\)</span>。比如在单粒子系统里，相空间就是粒子坐标空间的余切丛，我们在量子化的时候会假定动量和坐标的非对易性，也就是相空间几何的非对易性（或者说存在一个由普朗克常数刻画的最小相体积），这个非对易的程度是由普朗克常数<spanclass="math inline">\(\hbar\)</span>来决定的。对于一个一般的相空间，我们需要做的事情是一样的。</p><p>考虑一组辛形式<span class="math inline">\(\omega^{(k)} = k\omega\)</span>，其中<spanclass="math inline">\(k\)</span>充当了普朗克常数的地位，虽然原则上我们可以令<spanclass="math inline">\(k\)</span>为任意正实数，这里为了方便讨论我们令<spanclass="math inline">\(k\)</span>是整数，而当<spanclass="math inline">\(k\rightarrow\infty\)</span>的时候，我们会回到经典情况。对于一个拓扑空间而言，最自然的研究对象是上面的函数<spanclass="math inline">\(\mathbb{P}\rightarrow\mathbb{C}\)</span>。对于合适的函数集合，以及任意的<spanclass="math inline">\(k\)</span>，我们指定相空间的一个希尔伯特空间<spanclass="math inline">\(\mathcal{H}_k\)</span>，并且将函数提升为一个算符<spanclass="math inline">\(Q^{(k)}(f)\)</span>，并且要求如下几个条件：</p><ul><li><p><span class="math inline">\(\lim_{k\rightarrow \infty} k ||Q^{(k)}(f) Q^{(k)}(g) - Q^{(k)}(fg) || &lt; \infty,\)</span></p></li><li><p><span class="math inline">\([ Q^{(k)}(f) , Q^{(k)}(g) ] =-\frac{i}{k} Q^{(k)}(\{f,g\}) + \mathcal{O}(1/k^2),\)</span>其中函数的柏松括号定义为： <span class="math display">\[\{ f , g \} =\omega^{ij} \partial_i f \partial _j g.\]</span></p></li><li><p><span class="math inline">\((Q^{(k)}(f))^{\dagger} =Q^{(k)}(f^*),\)</span>即实函数代表的是自伴算符。</p></li></ul><p>如果在经典极限<span class="math inline">\(k\rightarrow\infty\)</span>下上述三个关系都可以满足的话，那么希尔伯特空间希尔伯特空间<spanclass="math inline">\(\mathcal{H}_k\)</span>以及算符<spanclass="math inline">\(Q^{(k)}(f)\)</span>便构成了相空间的一个量子化。</p><p>达成上述目标的途径并不唯一，实际上并没有一个通用的方式去做量子化，并且不同的途径所得到的量子化结果也无法保证是绝对相同的。通常来讲，我们有如下两种量子化的方案可选：</p><ul><li><p>薛定谔量子化：有的时候，我们可以将广义坐标和广义动量全局地区分开来，比如最常见的情况就是，相空间是某个流形<spanclass="math inline">\(M\)</span>的余切空间<spanclass="math inline">\(\mathcal{P}=T^*M\)</span>。单粒子的量子力学就是这种情况，此时<spanclass="math inline">\(M\)</span>就是粒子所在的空间。这样的话，波函数可以选取为<spanclass="math inline">\(M\)</span>上所有平方可积函数的集合<spanclass="math inline">\(\mathcal{H}=L^2(M)\)</span>，而动量则可以量子化为<spanclass="math inline">\(p_i = -i \hbar\nabla_i\)</span>。利用算符的正规排序，我们可以把任何函数写为希尔伯特空间中的算符。</p></li><li><p>有的时候相空间会有一些非常好的额外结构，使得我们可以选取更加方便的量子化手段。比如当相空间<spanclass="math inline">\(\mathcal{P}\)</span>是一个凯勒（K<spanclass="math inline">\(\ddot{\textrm{a}}\)</span>hler）流形的时候，那么凯勒势便给出了流形上的一个全纯线丛<spanclass="math inline">\(L \rightarrow\mathcal{P}\)</span>。在此时，我们可以使用所谓的几何量子化或凯勒量子化或Berezin-Toeplitz量子化的方式。</p></li></ul><h1 id="凯勒量子化">凯勒量子化</h1><p>我们这里不再对薛定谔量子化做过多介绍，而且简要介绍一下第二种凯勒量子化，这种量子化方式在对于相空间具有凯勒结构的时候是非常系统化也是非常方便的。</p><p>首先我们现简单回顾一下凯勒几何。考虑一个辛流形以及流形上的黎曼度规：<span class="math display">\[d s^2 = g_{\mu \nu} dx^{\mu} dx^{\nu},\quad\mu,\nu = 1,\cdots,2N.\]</span>如果我们可以给予流形一个和度规适配的复结构<spanclass="math inline">\(J\)</span>，并且辛形式在这个复结构下是一个正定的<spanclass="math inline">\((1,1)\)</span>形式，并且满足： <spanclass="math display">\[\omega(v_1, J v_2) = g (v_1,v_2),\]</span>那么我们就说这个流形是一个凯勒流形。在局域坐标下，上述条件实际上意味着：<span class="math display">\[\omega_{\mu \lambda} J_{\nu}^{\ \lambda} =g_{\mu \nu},\]</span> 如果我们选取一组复坐标讲复结构<spanclass="math inline">\(J\)</span>对角化： <span class="math display">\[J\left(\frac{\partial}{\partial z^{i}}\right) = i\left(\frac{\partial}{\partial z^{i}}\right),\quad J\left(\frac{\partial}{\partial \bar{z}^{i}}\right) = -i\left(\frac{\partial}{\partial \bar{z}^{i}}\right),\]</span>那么上述条件实际上暗示度规只有全纯-反全纯分量，并且和辛形式的关系为：<span class="math display">\[\omega = \frac{i}{2} g_{i \bar{j}} d z^i\wedge d \bar{z}^{\bar{j}}.\]</span>这个辛形式我们也经常叫做凯勒形式，并且我们可以局域地定一个一个所谓的（实的）凯勒势<spanclass="math inline">\(K\)</span>满足： <spanclass="math display">\[\omega = i \partial \bar{\partial}K.\]</span></p><p>相比复几何而言，凯勒几何可以附加一个额外的结构。注意到上述凯勒势<spanclass="math inline">\(K\)</span>有一个任意性： <spanclass="math display">\[K \sim K + f(z) + \bar{f}(\bar{z})，\]</span>也就是两个相差任何一个全纯函数的凯勒势是等价的，它们会给出同样的凯勒形式。因此我们可以用一个全纯线丛来刻画凯勒结构：<span class="math display">\[L \rightarrow \mathcal{P},\]</span>在这个线丛上我们可以赋予纤维上的一个协变导数<spanclass="math inline">\(\nabla\)</span>（或者联络），使得线丛的曲率为凯勒形式：<span class="math display">\[F(\nabla) = \omega,\]</span>那么上述的全纯变换即对应在线丛上选择不同的截面，在不同截面下的联络会有所不同，但是曲率则是保持不变的。上述凯勒势同样有一个几何意义，我们可以赋予纤维上的一个厄米度规<spanclass="math inline">\(h\)</span>，并且要求纤维丛的整体度规和协变导数相适配，这意味着如果我们选取纤维上的复坐标<spanclass="math inline">\((\phi,\bar{\phi})\)</span>的话，那么纤维上的联络可以写为（这里我不是很确定）：<span class="math display">\[\Gamma^{\phi}_{i \phi} = \frac{1}{2} h^{-1}\partial_{i} h = \frac{1}{2}\partial_{i} \log h ,\]</span> 黎曼曲率为：<span class="math display">\[R^{\phi}_{\ \phi i \bar{j}} = -\partial_{\bar{j}} \Gamma^{\phi}_{i \phi} = -\frac{1}{2} \partial_i\partial_{\bar{j}} \log h,\]</span> 因此我们可以自然地选取厄米度规为<span class="math display">\[h = e^{-K},\]</span>使得上述黎曼曲率给出的是凯勒形式。</p><p>接下来我们直接给出凯勒量子化的过程。首先我们定义希尔伯特空间<spanclass="math inline">\(\mathcal{H}_k\)</span>： <spanclass="math display">\[\mathcal{H}_k:= \textrm{Ker} \left[\bar{\partial}: \Omega^{0,0} \left(L^{\otimes k} \right) \rightarrow \Omega^{0,1}\left(L^{\otimes k} \right) \right],\]</span> 换言之就是<spanclass="math inline">\(L^{\otimes k}\)</span>取值的全纯函数，其中<spanclass="math inline">\(L^{\otimes k}\)</span>代表<spanclass="math inline">\(k\)</span>个<spanclass="math inline">\(L\)</span>的张量积。利用纤维上的度规我们可以定义希尔伯特空间<spanclass="math inline">\(\mathcal{H}_k\)</span>上的内积，即对任意两个矢量<spanclass="math inline">\(\psi_1,\psi_2 \in\mathcal{H}_k\)</span>，我们定义： <span class="math display">\[\langle\psi_1,\psi_2 \rangle_{\mathcal{H}_k} = \int_{\mathcal{P}}\frac{(\omega_2)^n}{n!} e^{-k K} \bar{\psi}_1 (\bar{z})\psi_2(z),\]</span> 其中<spanclass="math inline">\((\omega_2)^n/n!\)</span>是相空间<spanclass="math inline">\(\mathcal{P}\)</span>的体积元，<spanclass="math inline">\(e^{-kK}\)</span>是纤维<spanclass="math inline">\(L^{\otimesk}\)</span>上的度规。我们可以很容易看出，上述内积在以下变换下保持不变：<span class="math display">\[\left\{ \begin{array}{l}\psi(z) \rightarrow e^{k f(z)} \psi(z)\\\bar{\psi}(\bar{z}) \rightarrow e^{k \bar{f}(\bar{z})}\bar{\psi}(\bar{z})\\K \rightarrow K + f(z) + \bar{f}(\bar{z})\end{array}\right.\]</span>因此是一个良好定义的内积。最后给定相空间上任意一个函数<spanclass="math inline">\(g(z,\bar{z})\)</span>，我们可以利用内积定义其对应的算符<spanclass="math inline">\(Q^{(k)}(g)\)</span>为： <spanclass="math display">\[\langle \psi_1,Q^{(k)}(g) \psi_2\rangle_{\mathcal{H}_k} = \int_{\mathcal{P}} \frac{(\omega_2)^n}{n!}e^{-k K} \bar{\psi}_1 (\bar{z}) g(\bar{z},z) \psi_2(z).\]</span></p><p>接下来我们讨论一个简单的例子，即考虑二维相空间<spanclass="math inline">\(\mathbb{C}\)</span>为一个复平面，以及上面的凯勒形式：<span class="math display">\[\frac{\omega}{2\pi} = \frac{d p \wedge dq}{2\pi \hbar} = \frac{i}{2\pi \hbar} d z \wedge d \bar{z}.\]</span>这实际上正式一维自由粒子的相空间，薛定谔量子化（或正则量子化）给出的则是熟知的正则对易关系：<span class="math display">\[\left[ \hat{p} , \hat{q} \right] = -i\hbar.\]</span> 利用凯勒量子化，我们首先给出凯勒势： <spanclass="math display">\[K = z \bar{z} = |z|^2,\]</span>对于希尔伯特空间<spanclass="math inline">\(\mathcal{H}_k\)</span>而言，两个矢量的内积为：<span class="math display">\[\langle \psi_1,\psi_2\rangle_{\mathcal{H}_k} = \int \frac{dx dy}{\pi}e^{-k|z|^2} \bar{\psi}_1(\bar{z}) \psi_2(z).\]</span> 复平面上的任意函数可以由<spanclass="math inline">\(z,\bar{z}\)</span>生成，特别地，如果我们考虑<spanclass="math inline">\(z\)</span>与<spanclass="math inline">\(\bar{z}\)</span>对应的算符： <spanclass="math display">\[a^{\dagger} = \sqrt{k} Q^{(k)}(z),\quada=\sqrt{k} Q^{(k)}(\bar{z}),\]</span> 那么通过内积我们有： <spanclass="math display">\[\langle \psi_1,a^{\dagger} \psi_2\rangle_{\mathcal{H}_k} = \int \frac{dx dy}{\pi}e^{-k|z|^2}\sqrt{k}z  \bar{\psi}_1 (\bar{z}) \psi_2(z).\]</span> 以及 <spanclass="math display">\[\begin{aligned}    \langle \psi_1,a \psi_2 \rangle_{\mathcal{H}_k} &amp;= \int \frac{dxdy}{\pi}e^{-k|z|^2}\sqrt{k} \bar{z}  \bar{\psi}_1 (\bar{z})\psi_2(z)\nonumber \\    &amp;=\int \frac{dx dy}{\pi} \left(-\frac{1}{\sqrt{k}}\right)\partial_z \left( e^{-k|z|^2} \right) \bar{\psi}_1 (\bar{z})\psi_2(z)\nonumber \\    &amp;=\int \frac{dx dy}{\pi}  e^{-k|z|^2}  \bar{\psi}_1 (\bar{z})\left(\frac{1}{\sqrt{k}}\right)  \partial_z  \psi_2(z),\end{aligned}\]</span>因此不难看出二者满足对易关系： <span class="math display">\[[a ,a^{\dagger}]= 1,\]</span>它们生成的本征态即为相干态，与我们熟知的量子力学是一致的。</p><h1 id="特殊几何">特殊几何</h1><p>最后我们来讨论一种特殊的辛流形，它们可以被赋予一组投影（projective）的复坐标<spanclass="math inline">\(X^0,\cdots,X^N\)</span>，并且每个复坐标可以写为某种积分形式：<span class="math display">\[X^I = \int_{A^I} \Omega,\quad(I=0,\cdots,N)\]</span> 这种几何被称为特殊几何（Specialgeometry），并且常见于弦论中和超对称场论中的几何的形变模空间。接下来我们以Calabi-Yau3-fold的复结构模空间为例，讨论特殊几何的性质。对于一个Calabi-Yau 3-fold<span class="math inline">\(M\)</span>，它的复结构可以由流形上的<spanclass="math inline">\((3,0)\)</span>形式场<spanclass="math inline">\(\Omega\)</span>来刻画。我们选取一组（实的）3-cycle基底<spanclass="math inline">\(A^I,B_J (I,J =0,\cdots,h^{2,1})\)</span>，使得它们之间的相交数满足如下正则关系： <spanclass="math display">\[A^I \cap B_J = - B_J \cap A^I  = \deg^I_J,\quadA^I \cap A^J  = B_I \cap B_J = 0,\]</span>利用庞加莱对偶，相应的上同调基底记做<spanclass="math inline">\((\alpha_I,\beta^I)\)</span>，它们满足： <spanclass="math display">\[\int_{A^J}\alpha_I = \int \alpha_I \wedge \beta^J= \delta^J_I ,\quad \int_{B_J} \beta^I = \int \beta^I \wedge \alpha_J =- \delta^I_J.\]</span> 我们可以利用<spanclass="math inline">\((3,0)\)</span>形式场<spanclass="math inline">\(\Omega\)</span>在<spanclass="math inline">\(\alpha_I\)</span>上做投影得到坐标： <spanclass="math display">\[X^I = \int_{A^I} \Omega,\quad(I=0,\cdots,N).\]</span> 实际上上述<spanclass="math inline">\(h^{2,1}+1\)</span>个复坐标有一个冗余性，因为<spanclass="math inline">\((3,0)\)</span>形式场<spanclass="math inline">\(\Omega\)</span>如果放缩一个常数<spanclass="math inline">\(\Omega \rightarrow \lambda\Omega\)</span>，仍然会给出相同的复结构，因此上述坐标实际上是一组投影坐标：<span class="math display">\[(X^0,\cdots,X^{h^{2,1}}) \sim (\lambdaX^0,\cdots, \lambda X^{h^{2,1}}),\]</span> 局域来讲，我们可以选取坐标：<span class="math display">\[t^{\alpha} = \frac{X^{\alpha}}{X^0},\quad\alpha=1,\cdots,h^{2,1}.\]</span> 实际上我们知道，Calabi-Yau3-fold的复结构模空间正式<spanclass="math inline">\(h^{2,1}\)</span>维的，因此上述投影坐标<spanclass="math inline">\(\{X^I\}\)</span>（或者局域坐标<spanclass="math inline">\(\{t^{\alpha}\}\)</span>）已经是模空间的一组完备坐标了。因此如果我们考虑<spanclass="math inline">\((3,0)\)</span>形式场<spanclass="math inline">\(\Omega\)</span>在<spanclass="math inline">\(\beta^I\)</span>上的投影： <spanclass="math display">\[F_I = \int_{B^I} \Omega,\quad(I=0,\cdots,N).\]</span> 它们必然是依赖于投影坐标<spanclass="math inline">\(\{X^I\}\)</span>的函数，我们记做<spanclass="math inline">\(F_I(X)\)</span>。利用上述分解我们可以将<spanclass="math inline">\((3,0)\)</span>形式场<spanclass="math inline">\(\Omega\)</span>写为： <spanclass="math display">\[\Omega = X^I \alpha_I - F_I(X)\beta^I.\]</span></p><p>如果我们考虑Calabi-Yau 3-fold的复结构的一个微小形变，即考虑<spanclass="math inline">\(\partial_I \Omega\)</span>。对于一个<spanclass="math inline">\((3,0)\)</span>形式场，如果要求它在新的复结构下仍然为<spanclass="math inline">\((3,0)\)</span>形式场，那么相对于原来的复坐标，它会有一个由<spanclass="math inline">\((2,1)\)</span>形式刻画的微小形变（这也正是为何<spanclass="math inline">\(h^{2,1}\)</span>对应的是复结构模空间的维度），因此我们自然有：<span class="math display">\[\int \Omega \wedge \partial_I \Omega =0,\]</span> 将展开式带入我们有： <span class="math display">\[F_I = X^J\frac{\partial F_J}{X^I} = \frac{1}{2} \frac{\partial}{\partial X^I}\left( X^J F_J(X) \right),\]</span>换句话说，我们可以定义一个所谓的prepotential <spanclass="math inline">\(\mathcal{F}(X)\)</span>，满足： <spanclass="math display">\[\mathcal{F} = \frac{1}{2} X^J F_J(X),\quad  F_I =\frac{\partial \mathcal{F}}{\partial X^I}.\]</span> 另一方面，由于 <spanclass="math display">\[2\mathcal{F} = X^I \frac{\partial\mathcal{F}}{\partial X^I},\]</span> 因此prepotential <spanclass="math inline">\(\mathcal{F}\)</span>是关于投影坐标<spanclass="math inline">\(\{X^I\}\)</span>的二次同质（homogeneous）函数：<span class="math display">\[\mathcal{F}(\lambda X) = \lambda^2\mathcal{F}(X).\]</span> 最后，模空间上的凯勒形式通常写为： <spanclass="math display">\[K^{2,1} = - \log \left( i \int \Omega \wedge\bar{\Omega}\right),\]</span> 将<spanclass="math inline">\(\Omega\)</span>的展开式带入之后，模空间上全纯线丛的度规可以写为：<span class="math display">\[e^{-K^{2,1}} = -i \sum_{I=0}^{h^{2,1}}\left( X^I \bar{F}_I - \bar{X}^I F_I \right),\]</span>因此对于此类的几何，关键在于去寻找或构造prepotential <spanclass="math inline">\(\mathcal{F}\)</span>，我们称之为特殊几何。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;如果一个玻色理论的拉氏量仅仅包含时间的一次导数的话，比如Chern-Simons理论，那么在正则量子化的过程中，我们会发现广义动量实际上和广义坐标相重合了，那么相空间实际上就是坐标空间，并且在考虑量子化之后，相空间会变成一个非对易几何。具体地说，考虑如下一个作用量：</summary>
    
    
    
    <category term="Math" scheme="https://quantum-cyborg.github.io/categories/Math/"/>
    
    
    <category term="Geometry" scheme="https://quantum-cyborg.github.io/tags/Geometry/"/>
    
  </entry>
  
  <entry>
    <title>DMRG附录：用“自动机”来计算MPO</title>
    <link href="https://quantum-cyborg.github.io/2021/10/08/Physics/MPO/"/>
    <id>https://quantum-cyborg.github.io/2021/10/08/Physics/MPO/</id>
    <published>2021-10-08T11:18:00.000Z</published>
    <updated>2023-12-30T15:20:48.828Z</updated>
    
    <content type="html"><![CDATA[<p>在这一小节中，我们讨论如何从 Hamiltonian出发，得到其对应的MPO表示。本文所使用的方法，是借助于“自动机”的一种方法。首先，我们考虑一个简单的Heisenberg 自旋模型： <span id="more"></span></p><p><span class="math display">\[\hat{H}=J \sum_{i=1}^{L-1}\left(\frac{1}{2}\left(\hat{S}_i^{+}\hat{S}_{i+1}^{-}+\hat{S}_i^{-} \hat{S}_{i+1}^{+}\right)+\hat{S}_i^z\hat{S}_{i+1}^z\right)+h \sum_{i=1}^L \hat{S}_i^z\]</span> 我们以第一项为例，当 <span class="math inline">\(i\)</span>不在边界上的时候，其中任何一项都可以写成下面的这种形式： <spanclass="math display">\[\hat{I} \otimes \hat{I} \otimes \hat{S}^{+} \otimes \hat{S}^{-} \otimes\hat{I} \otimes \hat{I} \ldots .\]</span>让我们想象一个自动机，他从这条链的右端出发，然后一直移动到左端。这个自动机有如下几种内部状态：<spanclass="math inline">\(1(\hat{I})\)</span>, <spanclass="math inline">\(2(\hat{S}^-)\)</span>, <spanclass="math inline">\(4(\hat{S}^+)\)</span>. 注意 <spanclass="math inline">\(1\)</span> 代表链条右边的 <spanclass="math inline">\(\hat{I}\)</span>，链条左边的 <spanclass="math inline">\(\hat{I}\)</span> 我们用状态 <spanclass="math inline">\(5\)</span> 来表示。如下图所示，当我们从状态 <spanclass="math inline">\(1\)</span> 转换到状态 <spanclass="math inline">\(1\)</span> 的时候，中间会经过一个 <spanclass="math inline">\(\hat{I}\)</span>. 而从状态 <spanclass="math inline">\(1\)</span> 转换到状态 <spanclass="math inline">\(4\)</span> 的时候，中间需要经过一个 <spanclass="math inline">\(\hat{S}^-\)</span>. 而从状态 <spanclass="math inline">\(2\)</span> 转换到状态 <spanclass="math inline">\(5\)</span> 的时候，中间会经过一个 <spanclass="math inline">\(J/2\hat{S}^-\)</span>. <imgsrc="MPO_state.png" /></p><p>其他的项都是类似的，我们在上图中画出了所有可能的状态、和状态转移的方式。比如磁场项<span class="math inline">\(h\hat{S}^z\)</span> 可以实现状态从 <spanclass="math inline">\(1\)</span> 到 <spanclass="math inline">\(5\)</span> 的转变。任何一项，我们总是以状态 <spanclass="math inline">\(1\)</span> 开始，然后到状态 <spanclass="math inline">\(5\)</span>而结束。然后根据这张状态转移图，我们就可以写出 Hamiltonian 的 MPO表示了，分别用状态1,2,3,4,5作为矩阵的行和列，状态转移时所经过的算符作为矩阵元素的值，则可以写出MPO矩阵：<span class="math display">\[\hat{M}^{[i]}=\left[\begin{array}{ccccc}\hat{I} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\hat{S}^{+} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\hat{S}^z &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\\hat{S}^{-} &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\h \hat{S}^z &amp; (J / 2) \hat{S}^{-} &amp; J^z \hat{S}^z &amp; (J / 2)\hat{S}^{+} &amp; \hat{I}\end{array}\right]\]</span> 对于边界上的格点来说，比如右边界的 <spanclass="math inline">\(L\)</span>格点，他的右边没有其他的格点了，因此可以看作是从 <spanclass="math inline">\(1(\hat{I})\)</span>出发，然后转移到其他所有可能的状态。格点 <spanclass="math inline">\(1\)</span> 也是同理的，所以我们可以得到边界上的MPO 为 <span class="math display">\[\hat{M}^{[1]}=\left[\begin{array}{lllll}h \hat{S}^z &amp; (J / 2) \hat{S}^{-} &amp; J^z \hat{S}^z &amp; (J / 2)\hat{S}^{+} &amp; \hat{I}\end{array}\right] \quad \hat{M}^{[L]}=\left[\begin{array}{c}\hat{I} \\\hat{S}^{+} \\\hat{S}^z \\\hat{S}^{-} \\h \hat{S}^z\end{array}\right]\]</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在这一小节中，我们讨论如何从 Hamiltonian
出发，得到其对应的MPO表示。本文所使用的方法，是借助于“自动机”的一种方法。首先，我们考虑一个简单的
Heisenberg 自旋模型：</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="DMRG" scheme="https://quantum-cyborg.github.io/tags/DMRG/"/>
    
  </entry>
  
  <entry>
    <title>复流形的形变</title>
    <link href="https://quantum-cyborg.github.io/2021/09/07/Math/Deformation%20theory/"/>
    <id>https://quantum-cyborg.github.io/2021/09/07/Math/Deformation%20theory/</id>
    <published>2021-09-07T04:00:53.000Z</published>
    <updated>2023-12-24T16:20:50.029Z</updated>
    
    <content type="html"><![CDATA[<p>对于一个偶数维的流形<spanclass="math inline">\(M\)</span>，我们可以赋予其一个(Almost)复结构<spanclass="math inline">\(I \in \Lambda M^1 \otimes TM^1\)</span>: <spanclass="math display">\[I:TM \rightarrow TM,\]</span>这是一个切空间自身的同构映射，并且满足<spanclass="math inline">\(I^2=-1\)</span>。<span id="more"></span>因此如果我们考虑复化的切空间，我们可以利用<spanclass="math inline">\(I\)</span>的本征值<span class="math inline">\(\pmi\)</span>将其分为全纯部分与反全纯部分。比如说，考虑一组全纯坐标<spanclass="math inline">\(z^{\mu} = x^{\mu} + iy^{\mu}\)</span>的话，那么复结构在这组坐标下满足： <spanclass="math display">\[J \frac{\partial}{\partial x^{\mu}} =\frac{\partial}{\partial y^{\mu}},\quad J \frac{\partial}{\partialy^{\mu}} = -\frac{\partial}{\partial x^{\mu}},\]</span> 或者： <spanclass="math display">\[J \frac{\partial}{\partial z^{\mu}} = i\frac{\partial}{\partial z^{\mu}},\quad J \frac{\partial}{\partial\bar{z}^{\mu}} = -i \frac{\partial}{\partial\bar{z}^{\mu}}.\]</span></p><p>通常来讲，这个复结构必须要能够扩展到整个复流形上才可以，也就是要满足所谓的可积条件，也就是<spanclass="math inline">\(I\)</span>和自身的李括号为零。这里我们假定<spanclass="math inline">\(I\)</span>是可积的，那么给定了一个<spanclass="math inline">\(I\)</span>就给定了流形上的一个复结构。我们此处感兴趣的是给定流形<spanclass="math inline">\(M\)</span>上的所有不等价的复结构，因此我们需要考虑流形之间的微分同胚映射。考虑两个不同的复流形<spanclass="math inline">\((M,I)\)</span>以及<spanclass="math inline">\((M&#39;,I&#39;)\)</span>，并且存在一个微分同胚映射<spanclass="math inline">\(F:M\rightarrowM&#39;\)</span>，我们记映射的Jacobi矩阵为<span class="math inline">\(dF\in \Lambda M^1 \otimes TM&#39;^1\)</span>，它会把<spanclass="math inline">\(M\)</span>上的一个矢量映射为<spanclass="math inline">\(M&#39;\)</span>上相对应的矢量。那么如果两个流形的复结构满足<spanclass="math inline">\(dF \circ I = I&#39; \circdF\)</span>的话，那么这两个我们就称这两个流形是同构的。同样地，如果对于给定的流形<spanclass="math inline">\(M\)</span>，如果有两个不同的复结构<spanclass="math inline">\(I\)</span>和<spanclass="math inline">\(I&#39;\)</span>，它们两者是可以通过一个自同构映射<spanclass="math inline">\(F\)</span>联系起来的： <spanclass="math display">\[I&#39; = dF \circ I \circ (dF)^{-1},\]</span>那么我们就称这两个复结构<span class="math inline">\(I\)</span>和<spanclass="math inline">\(I&#39;\)</span>是等价的。</p><p>接下来我们就可以定义复流形<spanclass="math inline">\(M\)</span>的模空间。定义一个集合<spanclass="math inline">\(\mathcal{A}(M)\)</span>为<spanclass="math inline">\(M\)</span>上的所有可积复结构的集合，那么<spanclass="math inline">\(M\)</span>的模空间则定义为<spanclass="math inline">\(\mathcal{M} =\mathcal{A}(M)/\sim\)</span>，其中等价类<spanclass="math inline">\(\sim\)</span>是上述微分同胚所诱导的。令人惊讶的是，模空间实际上也是一个流形，并且在数学物理里面有很大的作用。接下来我们考虑一个最自然的问题，即模空间作为一个流形来讲，它的维度是多少？为了探究它的维度，我们需要考虑模空间<spanclass="math inline">\(\mathcal{M}\)</span>任意一点上的切空间，或者说给定复结构<spanclass="math inline">\(I\)</span>，它的不等价的无穷小形变是多少维的。</p><p>为了考虑这个问题，我们把<spanclass="math inline">\(M\)</span>上的复化切空间分解为全纯部分和反全纯部分<spanclass="math inline">\(T_{\mathbb{C}}M = TM^{1,0} \oplusTM^{0,1}\)</span>，并且<span class="math inline">\(I\)</span>在<spanclass="math inline">\(TM^{1,0}\)</span>和<spanclass="math inline">\(TM^{0,1}\)</span>上的本征值分别为<spanclass="math inline">\(i\)</span>和<spanclass="math inline">\(-i\)</span>。令<spanclass="math inline">\(I(t)\)</span>为一个连续的可积复结构的家族，并且满足<spanclass="math inline">\(I(0)=I\)</span>。那么对于任何<spanclass="math inline">\(t\)</span>，复化切空间可以根据复结构<spanclass="math inline">\(I(t)\)</span>分解为<spanclass="math inline">\(T_{\mathbb{C}}M = TM_t^{1,0} \oplusTM_t^{0,1}\)</span>。现在我们考虑<spanclass="math inline">\(t\)</span>是无穷小的情况，也就是说让复结构经历一个无穷小的变换。在这个无穷小变换下，原先为全纯的切矢量会混合一小部分反全纯的分量，从而在新的复结构下保持全纯。因此我们引入<spanclass="math inline">\(\phi(t) \in \LambdaM^{0,1}(TM^{1,0})\)</span>（切矢量取值的微分形式）满足： <spanclass="math display">\[\phi(t): TM^{0,1} \rightarrow TM^{1,0}\quad\textrm{使得}: v+\phi(t)(v) \in TM^{0,1}_{t},\]</span> 其中<spanclass="math inline">\(v\inTM^{0,1}\)</span>是任意反全纯的切矢量。对于<spanclass="math inline">\(t\)</span>非常小的时候，我们可以考虑级数展开：<span class="math display">\[\phi(t) = \phi_1 t + \phi_2 t^2 +\cdots,\]</span> 其中<span class="math inline">\(\phi_i \in \LambdaM^{0,1}(TM^{1,0})\)</span>。接下来，为了由<spanclass="math inline">\(\phi(t)\)</span>给出的新的复结构仍然是可积的，我们需要验证：<span class="math display">\[ \left[ TM^{0,1}_t , TM^{0,1}_t \right]\subset TM^{0,1}_t,\]</span>也就是反全纯（或者全纯）切矢量的李括号仍然是反全纯（或者全纯）。</p><p>我们可以把上述可积性条件利用<spanclass="math inline">\(\phi(t)\)</span>表示出来。实际上，我们可以将李括号的从切矢量扩展到所有切矢量取值的微分形式上：<span class="math display">\[[\quad,\quad]: \Lambda^{m,n}(T_p) \times\Lambda^{p,q}(T_p) \rightarrow \Lambda^{m+p,n+q}(T_p),\]</span>使得对于<span class="math inline">\(\alpha = \alpha_I \otimesv_I\)</span>，与<span class="math inline">\(\beta = \beta_J \otimesw_J\)</span>，两者之间的李括号满足： <span class="math display">\[[\alpha , \beta ] = \alpha_I \wedge \beta_J [v_I , w_J].\]</span>接下来将<spanclass="math inline">\(\phi\)</span>写为分量形式（我们把之后的<spanclass="math inline">\(t\)</span>省略掉）： <spanclass="math display">\[\phi = \phi_{ij} d \bar{z}_i \otimes\frac{\partial}{\partial z_j},\]</span> 那么可积性条件为： <spanclass="math display">\[\left[ \frac{\partial}{\partial \bar{z}_i} +\phi_{ik} \frac{\partial}{\partial z_k} , \frac{\partial}{\partial\bar{z}_j} + \phi_{jl} \frac{\partial}{\partial z_l} \right] \inT_t^{0,1},\]</span> 进一步可以写为： <span class="math display">\[\left(\left[ \frac{\partial}{\partial \bar{z}_i} , \phi_{jk}\frac{\partial}{\partial z_k} \right] + \left[\phi_{ik}\frac{\partial}{\partial z_k} , \frac{\partial}{\partial \bar{z}_j}\right] + \left[ \phi_{ik} \frac{\partial}{\partial z_k} , \phi_{jl}\frac{\partial}{\partial z_l} \right] \right) \in T_t^{0,1}.\]</span>利用李括号的性质，例如 <span class="math display">\[\left[\frac{\partial}{\partial \bar{z}_i} , \phi_{jk} \frac{\partial}{\partialz_k}\right] = \frac{\partial \phi_{jk}}{\partial \bar{z}_i}\frac{\partial}{\partial z_k},\quad \left[\phi_{ik}\frac{\partial}{\partial z_k} , \frac{\partial}{\partial \bar{z}_j}\right] = -\frac{\partial \phi_{ik}}{\partial \bar{z}_j}\frac{\partial}{\partial z_k},\]</span> 我们有： <spanclass="math display">\[\begin{aligned}    &amp;\left[ \frac{\partial}{\partial \bar{z}_i} , \phi_{jk}\frac{\partial}{\partial z_k} \right] + \left[\phi_{ik}\frac{\partial}{\partial z_k} , \frac{\partial}{\partial \bar{z}_j}\right] \nonumber \\    =&amp;\left(\frac{\partial \phi_{jk}}{\partial\bar{z}_i}  -\frac{\partial \phi_{ik}}{\partial \bar{z}_j}\right)\frac{\partial}{\partial z_k} \nonumber \\    =&amp; (\bar{\partial}\phi) \left(\frac{\partial}{\partial\bar{z}_i} , \frac{\partial}{\partial \bar{z}_j}\right),\end{aligned}\]</span> 其中<spanclass="math inline">\(\bar{\partial}\phi \in \LambdaM^{0,2}(TM^{1,0})\)</span>。另一方面，我们有： <spanclass="math display">\[\left[ \phi_{ik} \frac{\partial}{\partial z_k} ,\phi_{jl} \frac{\partial}{\partial z_l} \right] = [\phi ,\phi]\left(\frac{\partial}{\partial \bar{z}_i} ,\frac{\partial}{\partial \bar{z}_j} \right),\]</span>因此可积性条件可以写为： <spanclass="math display">\[((\bar{\partial}\phi) + [\phi , \phi])\left(\frac{\partial}{\partial \bar{z}_i} , \frac{\partial}{\partial\bar{z}_j} \right) \in T_t^{0,1}.\]</span> 但是方程左边是属于<spanclass="math inline">\(T^{1,0}\)</span>的，而当<spanclass="math inline">\(t\)</span>十分小的时候<spanclass="math inline">\(T^{0,1}_t\)</span>占据主导地位的是<spanclass="math inline">\(T^{0,1}\)</span>分量，因此两者不属于同一个空间，唯一的可能是在<spanclass="math inline">\(t\)</span>十分小的时候： <spanclass="math display">\[(\bar{\partial}\phi) + [\phi , \phi] =0.\]</span> 这个被称为Maurer-Cartan方程。如果我们考虑关于<spanclass="math inline">\(t\)</span>的级数展开<spanclass="math inline">\(\phi = \phi_it^i\)</span>，那么上述方程可以写为一系列的递推方程： <spanclass="math display">\[\begin{aligned}    &amp;t^1: \quad 0 = \bar{\partial} \phi_1, \nonumber \\    &amp;t^2: \quad 0 = \bar{\partial} \phi_2 + [\phi_1,\phi_1]\nonumber \\    &amp;\cdots\end{aligned}\]</span>如果我们只考虑无穷小变换的话，或者模空间的切矢量，那么第一个方程就足够了，它告诉我们<spanclass="math inline">\(\phi_1\in \LambdaM^{0,1}(TM^{1,0})\)</span>作为一个反全纯1-形式场，必须是闭的。</p><p>因此对于任意<span class="math inline">\(\LambdaM^{0,1}(TM^{1,0})\)</span>中的一个闭的元素，我们都可以构造出<spanclass="math inline">\(\phi_1\)</span>，也就是模空间的一个切矢量，并且通过递推关系式得到其余的<spanclass="math inline">\(\phi_i\)</span>。但是我们仍然需要探究在什么情况下，两个<spanclass="math inline">\(\phi_1\)</span>在微分同胚的意义下给出同样的切矢量场。</p><p>我们假设<span class="math inline">\(F_t\)</span>是<spanclass="math inline">\(M\)</span>上的一个单参微分同胚群，我们考虑在<spanclass="math inline">\(t=0\)</span>时上述单参微分同胚群生成的切矢量场，记为<spanclass="math inline">\(F_i \frac{\partial}{\partialx^i}\)</span>。详细地来说，在<spanclass="math inline">\(M\)</span>上的任一点<spanclass="math inline">\(p\)</span>，我们可以考虑一条轨道曲线<spanclass="math inline">\(F_t(p)\)</span>，它在<spanclass="math inline">\(t=0\)</span>点的切矢量对应的就是上述切矢量场在<spanclass="math inline">\(p\)</span>点的取值。我们将上述矢量场记为： <spanclass="math display">\[\frac{d F_t}{d t}|_{t=0} = F_i\frac{\partial}{\partial x^i} \in \Lambda M^{0}(TM),\]</span>这里的<span class="math inline">\(\LambdaM^{0}(TM)\)</span>意味切矢量取值的0-形式场，也就是切矢量场。</p><p>对于一个复流形<spanclass="math inline">\((M,I)\)</span>上的单参微分同胚群<spanclass="math inline">\(F_t\)</span>，我们可以将<spanclass="math inline">\(t=0\)</span>点的切矢量场用复参数记为： <spanclass="math display">\[f_i \frac{\partial}{\partial z^i} + \bar{f}_i\frac{\partial}{\partial \bar{z}^i},\]</span> 其中<spanclass="math inline">\(f_i\)</span>与<spanclass="math inline">\(\bar{f}_i\)</span>互为复共轭。给定一个切矢量场，我们可以考虑由它生成的无穷小变换<spanclass="math inline">\(F_t\)</span>。根据之前的讨论，新的复结构为<spanclass="math inline">\(I&#39; = dF_t \circ I \circ(dF_t)^{-1}\)</span>，以及对应的切空间的全纯部分为： <spanclass="math display">\[TM^{0,1}_t = dF_t (TM^{0,1}),\]</span>回忆起<span class="math inline">\(dF_t \in \Lambda M \otimesTM\)</span>为Jacobi矩阵。坐标的无穷小变换可以写为： <spanclass="math display">\[\begin{aligned}    z&#39;_i &amp;= z_i + t f_i(z,\bar{z}) + \mathcal{O}(t^2),\nonumber\\    \bar{z}&#39;_i &amp;= \bar{z}_i + t \bar{f}_i(z,\bar{z}) +\mathcal{O}(t^2),\end{aligned}\]</span> 接下来我们可以计算相应的<spanclass="math inline">\(\phi(t)\)</span>，我们有： <spanclass="math display">\[\begin{aligned}    \frac{\partial}{\partial \bar{z}&#39;_i} &amp;= \frac{\partial\bar{z}_j}{\partial \bar{z}&#39;_i} \frac{\partial}{\partial \bar{z}_j}+ \frac{\partial z_j}{\partial \bar{z}&#39;_i} \frac{\partial}{\partialz_j} \nonumber \\    &amp;= \frac{\partial}{\partial \bar{z}_i} - t \frac{\partialf_j(z,\bar{z})}{\partial \bar{z}_i} \frac{\partial}{\partialz_j},\end{aligned}\]</span> 因此我们有 <spanclass="math display">\[(\phi_1)_{ij} = - \frac{\partialf_j(z,\bar{z})}{\partial \bar{z}_i},\]</span> 即 <spanclass="math display">\[\phi_1 = \bar{\partial} \left(-f_j(z,\bar{z})\frac{\partial}{\partial z_j}\right),\]</span>因此为Exact的。反过来，如果<spanclass="math inline">\(\phi_1\)</span>是Exact的，那么我们可以得到一个切矢量场并诱导出一个微分同胚变换，而相应的复结构<spanclass="math inline">\(I&#39;\)</span>则可以由这个微分同胚诱导的来，因此和原来的复结构等价。</p><p>结合上面的讨论，我们可以得出结论：给定一个复流形<spanclass="math inline">\(M\)</span>，它的模空间的切矢量和<spanclass="math inline">\(TM^{1,0}\)</span>取值的上同调群<spanclass="math inline">\(H^{0,1}(TM^{1,0})\)</span>之间有一一对应的关系。或者利用Dolbeault上同调和C<spanclass="math inline">\(\check{\textrm{e}}\)</span>ch上同调之间对应关系，我们也可以将上述同调群记为<spanclass="math inline">\(H^1(TM^{1,0})\)</span>，此处应该将<spanclass="math inline">\(TM^{1,0}\)</span>理解为<spanclass="math inline">\(M\)</span>上的一个层。通常我们也将全纯部分的复切空间记为<spanclass="math inline">\(\mathcal{T}M\)</span>。</p><p>接下来我们来考虑二维复流形，也就是黎曼面的模空间的维度，为此我们需要利用Grothendieck-Riemann-Rock公式。对于底流形为<spanclass="math inline">\(M\)</span>一个复的矢量丛<spanclass="math inline">\(E\)</span>，我们可以考虑<spanclass="math inline">\(M\)</span>上的层取值的C<spanclass="math inline">\(\check{\textrm{e}}\)</span>ch上同调群。原则上，这个上同调群并不好计算，我们可以考虑一个特殊不变量，即矢量丛<spanclass="math inline">\(E\)</span>的欧拉数<spanclass="math inline">\(\chi(E) = \sum_k (-1)^k \dimH^k(E)\)</span>，它可以利用上述所说的Grothendieck-Riemann-Rock公式来计算：<span class="math display">\[\chi(E) = \int_M ch(E) \wedgetd(E),\]</span> 其中<spanclass="math inline">\(ch(E)=1+c_1(E)+c_2(E)+\cdots\)</span>是陈类，<spanclass="math inline">\(td(M)=1+\frac{1}{2}c_1(M)+\cdots\)</span>是Todd类。对于二维黎曼面来说，利用上述公式我们有：<span class="math display">\[\begin{aligned}    \dim_{\mathbb{C}}H^0(\mathcal{T}M) -\dim_{\mathbb{C}}H^1(\mathcal{T}M) &amp;=\int_X(1+c_1(\mathcal{T}M))(1+\frac{1}{2}c_1(\mathcal{T}M)) \nonumber \\    &amp;= \frac{3}{2}\int_M c_1(\mathcal{T}M) =3-3g,\end{aligned}\]</span> 其中最后一步是因为<spanclass="math inline">\(\int_M c_1(\mathcal{T}M) =2-2g\)</span>是黎曼面的欧拉示性数（注意我们谈及陈类的时候，都是对复矢量丛来谈的），因此我们有：<span class="math display">\[\dim_{\mathbb{C}}H^1(\mathcal{T}M) = 3g-3 +\dim_{\mathbb{C}}H^0(\mathcal{T}M).\]</span> 而后者<spanclass="math inline">\(H^0(\mathcal{T}M)\)</span>对应的是黎曼面上的全局的切矢量场，这个实际上是黎曼面上的共形Killing矢量场（global共形变换的生成元，注意到二维黎曼面上共形变换等价于全纯变换）。当<spanclass="math inline">\(g=0\)</span>的时候，球面上一共有六个（复三维）不等价的共形Killing矢量场，因此<spanclass="math inline">\(H^0(\mathcal{T}M)=3\)</span>，模空间的维度为零；当<spanclass="math inline">\(g=1\)</span>的时候，圆环面上有两个（复一维）共形Killing矢量场，因此<spanclass="math inline">\(H^0(\mathcal{T}M)=1\)</span>，模空间维度为1。对于<spanclass="math inline">\(g&gt;1\)</span>的情况，<spanclass="math inline">\(H^0(\mathcal{T}M)=0\)</span>，从而模空间的维度为<spanclass="math inline">\(3g-3\)</span>。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Daniel Huybrechts, ComplexGeometry: An introduction<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;对于一个偶数维的流形&lt;span
class=&quot;math inline&quot;&gt;\(M\)&lt;/span&gt;，我们可以赋予其一个(Almost)复结构&lt;span
class=&quot;math inline&quot;&gt;\(I \in \Lambda M^1 \otimes TM^1\)&lt;/span&gt;: &lt;span
class=&quot;math display&quot;&gt;\[I:TM \rightarrow TM,\]&lt;/span&gt;
这是一个切空间自身的同构映射，并且满足&lt;span
class=&quot;math inline&quot;&gt;\(I^2=-1\)&lt;/span&gt;。</summary>
    
    
    
    <category term="Math" scheme="https://quantum-cyborg.github.io/categories/Math/"/>
    
    
    <category term="Differential Geometry" scheme="https://quantum-cyborg.github.io/tags/Differential-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 踩坑记录</title>
    <link href="https://quantum-cyborg.github.io/2021/08/03/CS/Blog/Hexo%20Problems/"/>
    <id>https://quantum-cyborg.github.io/2021/08/03/CS/Blog/Hexo%20Problems/</id>
    <published>2021-08-03T05:27:57.000Z</published>
    <updated>2024-04-13T03:56:08.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="公式渲染">公式渲染</h1><p>公式渲染是最麻烦的一个坑，Hexo官方自带的渲染引擎marked完全没法用，需要更换到其他的渲染引擎，我第一个尝试的是kramed：<span id="more"></span></p><h2 id="kramed">kramed</h2><p>卸载自带的marked，安装kramed <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">npm un hexo-renderer-marked <span class="hljs-attr">--save</span><br>npm <span class="hljs-selector-tag">i</span> hexo-renderer-kramed <span class="hljs-attr">--save</span><br></code></pre></td></tr></table></figure>然后需要修改文件<code>node_modules\kramed\lib\rules\inline.js</code><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//  escape: /^\\([\\`*&#123;&#125;\[\]()#$+\-.!_&gt;])/,</span><br><span class="hljs-attr">escape</span>: <span class="hljs-regexp">/^\\([`*\[\]()#$+\-.!_&gt;])/</span><br><span class="hljs-comment">//  em: /^\b_((?:__|[\s\S])+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,</span><br><span class="hljs-attr">em</span>: <span class="hljs-regexp">/^\*((?:\*\*|[\s\S])+?)\*(?!\*)/</span><br></code></pre></td></tr></table></figure>在做了这些修改之后，LaTeX中的一些字符仍然会和Markdown本身的特殊符号相冲突。比如<code>*</code>这个符号，在LaTeX的公式书写中非常常见，但kramed会将其解析为Markdown中的加粗符号，导致出现一系列的问题。</p><h2 id="pandoc">pandoc</h2><p>然后我就改用了pandoc.</p><p>首先需要去官网下载安装pandoc软件，然后将其命令所在的目录加入到系统环境变量中去（按照不同的操作系统具体来操作）。然后在npm中安装<code>hexo-renderer-pandoc</code> <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">npm un hexo-renderer-marked --save<br>npm un hexo-renderer-kramed --save <br>npm i hexo-renderer-pandoc --save<br></code></pre></td></tr></table></figure></p><p>还需要在主题的配置文件<code>_config.yml</code>中打开mathjax的开关<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">mathjax</span>:<br><span class="hljs-attr">enable</span>: <span class="hljs-literal">true</span><br><span class="hljs-attr">per_page</span>: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></p><p>以及在文章的头部打开mathjax开关 <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-attr">mathjax:</span> <span class="hljs-literal">true</span><br><span class="hljs-string">--</span><br></code></pre></td></tr></table></figure>这样就可以正常渲染各种公式了。</p><h1 id="主题设置">主题设置</h1>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;公式渲染&quot;&gt;公式渲染&lt;/h1&gt;
&lt;p&gt;公式渲染是最麻烦的一个坑，Hexo官方自带的渲染引擎marked完全没法用，需要更换到其他的渲染引擎，我第一个尝试的是kramed：</summary>
    
    
    
    <category term="CS-MISC" scheme="https://quantum-cyborg.github.io/categories/CS-MISC/"/>
    
    
    <category term="Blog" scheme="https://quantum-cyborg.github.io/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>Sheaf</title>
    <link href="https://quantum-cyborg.github.io/2021/08/01/Math/Sheaf/"/>
    <id>https://quantum-cyborg.github.io/2021/08/01/Math/Sheaf/</id>
    <published>2021-08-01T12:00:53.000Z</published>
    <updated>2023-12-24T16:21:20.491Z</updated>
    
    <content type="html"><![CDATA[<p>层（Sheaf）是一个很有趣的数学概念。给定一个拓扑空间<spanclass="math inline">\(X\)</span>，我们可以考虑给这个拓扑空间附加一些额外的信息。比如，我们可以考虑<spanclass="math inline">\(X\)</span>上的任何光滑函数，可以是定义在整个<spanclass="math inline">\(X\)</span>上的，也可以是定义在<spanclass="math inline">\(X\)</span>的某一个开集上的，我们可以把这些定义在开集上的光滑函数称为一个层<spanclass="math inline">\(\mathscr{F}\)</span>。<span id="more"></span>抽象地来说，<spanclass="math inline">\(\mathscr{F}\)</span>是一个逆变的函子，它把<spanclass="math inline">\(X\)</span>上的任何的开集映射到一个阿贝尔群上（并且把开集之间的映射，映射为函数在开集上的拖回映射），这个阿贝尔群就是这个开区间上光滑函数的集合。具体来说，给定一个开集<spanclass="math inline">\(U\subset X\)</span>，那么<spanclass="math inline">\(\mathcal{F}(U)\)</span>就是定义在这个开集<spanclass="math inline">\(U\)</span>上的所有光滑函数的集合。我们知道，一个流形上的光滑函数通常满足一些额外的结构，比如两个定义在不同开集<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>上的光滑函数，如果在交集<spanclass="math inline">\(U \capV\)</span>上相同的话，那么我们总可以把这个光滑函数扩展到整个并集<spanclass="math inline">\(U \cup V\)</span>上面。这是光滑函数层<spanclass="math inline">\(\mathscr{F}\)</span>的一个局域性质，而层实际上也正是被这种局域性质所刻画的，在下面的讨论中我们将首先引入预层（Presheaf），然后给它附加一些额外的局域结构或者信息，从而得到层。</p><h1 id="预层presheaf">预层（Presheaf）</h1><p>给定一个拓扑空间<span class="math inline">\(X\)</span>，那么<spanclass="math inline">\(X\)</span>上的一个预层<spanclass="math inline">\(\mathscr{F}\)</span>包含如下的信息：</p><ul><li><p>对于<span class="math inline">\(X\)</span>的任何一个开集<spanclass="math inline">\(U\subset X\)</span>，<spanclass="math inline">\(\mathscr{F}\)</span>会把它映射为一个阿贝尔群<spanclass="math inline">\(\mathscr{F}(U)\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="实际上不需要是阿贝尔群，只不过我们这里只讨论阿贝尔的情况。">[1]</span></a></sup>。</p></li><li><p>如果<span class="math inline">\(V\subset U\)</span>是<spanclass="math inline">\(U\)</span>的一个开子集，那么存在一个"限制同态"：<spanclass="math inline">\(\rho_{UV} : \mathscr{F}(U) \rightarrow\mathscr{F}(V)\)</span>，它会把<spanclass="math inline">\(U\)</span>上的信息限制到<spanclass="math inline">\(V\)</span>上，并且满足：</p><ul><li><p><span class="math inline">\(\mathscr{F} (\emptyset) =0\)</span>。</p></li><li><p><spanclass="math inline">\(\rho_{UU}\)</span>是恒等映射。</p></li><li><p>如果<span class="math inline">\(W \subset V \subsetU\)</span>的话，那么限制同态满足<span class="math inline">\(\rho_{UW} =\rho_{UV} \rho_{VW}\)</span>。</p></li></ul></li></ul><p>满足上述所描述的条件，我们就可以把<spanclass="math inline">\(\mathscr{F}\)</span>称为<spanclass="math inline">\(X\)</span>上的一个预层。给定一个开集<spanclass="math inline">\(U\)</span>，我们可以谈论预层<spanclass="math inline">\(\mathscr{F}\)</span>在上面的"取值"<spanclass="math inline">\(\mathscr{F}(U)\)</span>，这实际上也是一个集合，并且这个集合<spanclass="math inline">\(\mathscr{F}(U)\)</span>里的任何一个元素<spanclass="math inline">\(\sigma\)</span>我们称之为一个截面（Section）。如果<spanclass="math inline">\(V \subset U\)</span>是一个开子集，那么<spanclass="math inline">\(\sigma\)</span>可以利用限制同态<spanclass="math inline">\(\rho_{UV}\)</span>限制在<spanclass="math inline">\(V\)</span>上，我们记为<spanclass="math inline">\(\sigma_{V} \in\mathscr{F}(V)\)</span>，也可以说<spanclass="math inline">\(\sigma_{V}\)</span>是截面<spanclass="math inline">\(\sigma\)</span>在<spanclass="math inline">\(V\)</span>上的取值。最后，如果将<spanclass="math inline">\(X\)</span>本身作为一个开集，那么<spanclass="math inline">\(\mathscr{F}(X)\)</span>中的一个元素我们称之为一个整体截面（globalsection）。</p><p>这里谈到的的截面实际上和纤维丛中的截面是同样的东西。给定一个纤维丛<spanclass="math inline">\(FX\)</span>，其中<spanclass="math inline">\(X\)</span>是基底，<spanclass="math inline">\(F\)</span>是基底上的纤维，我们这里假定<spanclass="math inline">\(F\)</span>本身也是一个阿贝尔群（比如矢量丛）。那么我们可以谈论纤维丛<spanclass="math inline">\(FX\)</span>的截面，并且对于所有开区间的截面的集合实际上就构成了一个层。纤维丛和层是初学者容易混淆的两个概念，需要注意一下，两者虽然有联系，但是并不相同。</p><h1 id="层sheaf">层（Sheaf）</h1><p>给定了拓扑空间<span class="math inline">\(X\)</span>上的一个预层<spanclass="math inline">\(\mathscr{F}\)</span>，如果它满足如下的额外条件，我们将称之为层：</p><ul><li><p>（A）如果<span class="math inline">\(U,V \subsetX\)</span>是<span class="math inline">\(X\)</span>的两个开子集，<spanclass="math inline">\(\sigma \in \mathscr{F}(U)\)</span>与<spanclass="math inline">\(\tau \in \mathscr{F}(V)\)</span>则是<spanclass="math inline">\(U,V\)</span>上的两个截面。如果<spanclass="math inline">\(\sigma_{U \cap V} = \tau_{U \capV}\)</span>的话，那么一定存在<span class="math inline">\(\nu \in\mathscr{F}(U \cup V)\)</span>使得<span class="math inline">\(\nu_U =\sigma\)</span>以及<span class="math inline">\(\nu_V =\tau\)</span>。</p></li><li><p>（B）如果<span class="math inline">\(U,V \subsetX\)</span>是<span class="math inline">\(X\)</span>的两个开子集，<spanclass="math inline">\(\sigma \in \mathscr{F}(U \cup V)\)</span>是<spanclass="math inline">\(U\cup V\)</span>上的一个截面并且满足<spanclass="math inline">\(\sigma_U = \sigma_V = 0\)</span>，那么一定有<spanclass="math inline">\(\sigma=0\)</span>。</p></li></ul><p>现在我们来看一下这两个条件是什么意思。条件（A）实际上是说，两个隶属于不同开集<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>的截面，只要它们在公共开集<spanclass="math inline">\(U \capV\)</span>中是相等的，那么我们总可以把这两个截面粘在一起变成在<spanclass="math inline">\(U\cupV\)</span>中的一个截面，就像之前的光滑函数一样。条件（B）的意思是，比如我找到了某个开集<spanclass="math inline">\(U\)</span>的一个开覆盖<spanclass="math inline">\(\{ U_i \}\)</span>，如果有一个<spanclass="math inline">\(U\)</span>上的截面<spanclass="math inline">\(\sigma \in\mathscr{F}(U)\)</span>，并且它在任何一个开子集<spanclass="math inline">\(U_i\)</span>上的取值都是零，那么只有一种可能性，那就是<spanclass="math inline">\(\sigma\)</span>本身就是零。这个条件实际上也可以引申为，如果<spanclass="math inline">\(U\)</span>上的两个截面<spanclass="math inline">\(\sigma,\tau\)</span>在任何一个开子集<spanclass="math inline">\(U_i\)</span>上的取值都相等，那么必然有<spanclass="math inline">\(\sigma = \tau\)</span>。</p><p>上述这两个条件是反映的是层的局域性质：（A）使得我们可以利用小开集中的信息去粘贴出大开集的信息，也就是从小到大，（B）则使得我们可以把大开集中的信息分解到小开集之中，也就是从大到小。这使得我们可以将拓扑空间<spanclass="math inline">\(X\)</span>不断地细化，去分析每个点附近的局域信息，而这些所有的局域信息加在一起则构成了完整的层，或者完整的信息。因此我们说，<strong>层是被局域信息所定义的</strong>。</p><h1 id="两个反例">两个反例</h1><p>最后我们来看两个不满足上述条件（A）或（B）的预层的例子，来体会一下层与预层的区别，以及为什么说层是被局域信息所定义的。</p><p>第一个例子是所谓的常数预层（ConstantPresheaf），也就是对于任何一个开集，它的截面是一个常数，这个层不满足条件（A）。比如我们考虑两个不连通的开区间<spanclass="math inline">\(U,V \in X\)</span>满足<spanclass="math inline">\(U \cap V = \emptyset\)</span>，考虑<spanclass="math inline">\(U\)</span>上的截面<spanclass="math inline">\(\sigma\)</span>和<spanclass="math inline">\(V\)</span>上的截面<spanclass="math inline">\(\tau\)</span>。因为<span class="math inline">\(U\cap V = \emptyset\)</span>，所以说我们自然有<spanclass="math inline">\(\sigma_{U \cap V} = \tau_{U \capV}\)</span>，但是只有当<spanclass="math inline">\(\sigma\)</span>和<spanclass="math inline">\(\tau\)</span>是同一个常数的时候，我们才能够将两者粘在一起，否则粘出来的截面在<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>上会有不同的取值，因此就是不是<spanclass="math inline">\(U\cupV\)</span>上的一个截面了。因此对于这个例子，如果只知道<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>中的信息，我们实际上对整体的把握仍然不够。</p><p>第二个例子要复杂一些，它不满足第二个看起来最自然不过的条件（B）。我们考虑在一个复流形<spanclass="math inline">\(X\)</span>上的所有全纯函数构成的层<spanclass="math inline">\(\mathscr{O}\)</span>，以及另外一个由所有<strong>处处不为零</strong>的全纯函数构成的层<spanclass="math inline">\(\mathscr{O}^*\)</span><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="对于任何开区间$U$，$\mathscr{O}(U)$是一个加法意义下构成的阿贝尔群，而$\mathscr{O}^*$则是在一个乘法意义下构成的阿贝尔群，这个区别要注意一下。">[2]</span></a></sup>。接下来我们考虑指数映射<spanclass="math inline">\(\exp\)</span>，很明显对于任何一个全纯函数<spanclass="math inline">\(f\)</span>，<span class="math inline">\(\expf\)</span>仍然是全纯函数，并且处处不为零，因此我们有映射： <spanclass="math display">\[\exp: \mathscr{O} \rightarrow\mathscr{O}^*.\]</span>接下来我们可以考虑上述映射的余核（Cokernel）coker(<spanclass="math inline">\(\exp\)</span>)，也就是所有不能够写成一个全纯函数的指数的，处处非零的全纯函数。实际上容易发现，coker(<spanclass="math inline">\(\exp\)</span>)恰恰就是一个不满足条件（B）的预层。比如说，我们考虑<spanclass="math inline">\(X=\mathbf{C}^{*}\)</span>是去掉了原点的整个复平面，其复坐标是<spanclass="math inline">\(z\)</span>。那么<spanclass="math inline">\(z\)</span>本身就是一个处处不为零的全纯函数，因此<spanclass="math inline">\(z \in\mathscr{O}^{*}(\mathbf{C}^{*})\)</span>是层<spanclass="math inline">\(\mathscr{O}^*\)</span>的一个截面，并且<spanclass="math inline">\(\log z\)</span>则并不是在<spanclass="math inline">\(\mathbf{C}^*\)</span>上整体定义的全纯函数，因为<spanclass="math inline">\(z\)</span>绕原点转一圈会出来一个额外的<spanclass="math inline">\(2\pi i\)</span>的相位。因此我们有<spanclass="math inline">\(z \in\textrm{Ker}(\exp)(\mathbf{C}^*)\)</span>，也就是预层<spanclass="math inline">\(\textrm{Ker}(\exp)(\mathbf{C}^*)\)</span>的一个（不为零）截面。然后我们可以考虑两个开集<spanclass="math inline">\(U,V\)</span>，比如让<spanclass="math inline">\(U\)</span>包含<spanclass="math inline">\(\mathbf{C}^*\)</span>中所有相位<spanclass="math inline">\(\textrm{arg}(z)\)</span>在<spanclass="math inline">\((-\epsilon , 3/2 \pi)\)</span>的点，而<spanclass="math inline">\(V\)</span>包含<spanclass="math inline">\(\mathbf{C}^*\)</span>中所有相位<spanclass="math inline">\(\textrm{arg}(z)\)</span>在<spanclass="math inline">\((+\epsilon ,- 3/2 \pi)\)</span>的点，其中<spanclass="math inline">\(\epsilon\)</span>是一个小量，那么显然<spanclass="math inline">\(\mathbf{C}^* = U \cupV\)</span>。但是当我们尝试把<span class="math inline">\(z \in\textrm{Ker}(\exp)(\mathbf{C}^*)\)</span>分解到两个开集<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>上的时候，我们会发现在<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>上<span class="math inline">\(\logz\)</span>都是可以整体定义的，因为<spanclass="math inline">\(U,V\)</span>中都不包含任何一个绕原点的回路，因此不会出现相位无法确定的问题，这也就意味着<spanclass="math inline">\(z_U = z_V = 0\)</span>但是<spanclass="math inline">\(z\)</span>本身不为零，也就违反了条件（B）。因此对于这个例子，如果只知道<spanclass="math inline">\(U\)</span>和<spanclass="math inline">\(V\)</span>中的信息，我们同样对整体的把握仍然不够。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1"class="footnote-text"><span>实际上不需要是阿贝尔群，只不过我们这里只讨论阿贝尔的情况。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>对于任何开区间<spanclass="math inline">(U)</span>，<spanclass="math inline">((U))</span>是一个加法意义下构成的阿贝尔群，而<spanclass="math inline">(^*)</span>则是在一个乘法意义下构成的阿贝尔群，这个区别要注意一下。<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">&lt;p&gt;层（Sheaf）是一个很有趣的数学概念。给定一个拓扑空间&lt;span
class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;，我们可以考虑给这个拓扑空间附加一些额外的信息。比如，我们可以考虑&lt;span
class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;上的任何光滑函数，可以是定义在整个&lt;span
class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;上的，也可以是定义在&lt;span
class=&quot;math inline&quot;&gt;\(X\)&lt;/span&gt;的某一个开集上的，我们可以把这些定义在开集上的光滑函数称为一个层&lt;span
class=&quot;math inline&quot;&gt;\(\mathscr{F}\)&lt;/span&gt;。</summary>
    
    
    
    <category term="Math" scheme="https://quantum-cyborg.github.io/categories/Math/"/>
    
    
    <category term="Differential Geometry" scheme="https://quantum-cyborg.github.io/tags/Differential-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>Spin Structure</title>
    <link href="https://quantum-cyborg.github.io/2021/07/18/Math/Spin%20Structure/"/>
    <id>https://quantum-cyborg.github.io/2021/07/18/Math/Spin%20Structure/</id>
    <published>2021-07-18T03:33:53.000Z</published>
    <updated>2023-12-24T16:21:25.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="clifford代数">Clifford代数</h1><p>在讲自旋之前，我们首先需要关于Clifford代数的一些基本知识。Clifford代数的定义大致有两种，一种是比较抽象的偏数学的定义，在这里我们并不打算讨论这种抽象的定义方式。另外一种是比较具体的，或者说是比较物理的定义，最早是由狄拉克给出的并且仍然在所有量子场论的教科书中使用的定义方式，我们这里将采取这种。<span id="more"></span> 考虑一个线性空间<spanclass="math inline">\(V\)</span>并选择一组基底<spanclass="math inline">\(\{e_i\}\)</span>，其中<spanclass="math inline">\(i=1,2,\cdots,n =\textrm{dim}(V)\)</span>，并且考虑线性空间上一个度规<spanclass="math inline">\(g(e_i,e_j) \equivg_{ij}=g_{ji}\)</span>，那么对于一个在此线性空间下的Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span><sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="Clifford代数是结合代数。">[1]</span></a></sup>我们可以建立起一个线性映射<spanclass="math inline">\(f:V \rightarrow \textrm{Cl}(V,g)\)</span>使得<spanclass="math inline">\(f(e_i)\equiv\Gamma_i\)</span>为代数的生成元，并且满足<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="注意这里的约定和很多理论物理书籍里的约定并不相同，双方的$\Gamma$矩阵差一个虚数$i$。">[2]</span></a></sup>：<span class="math display">\[\Gamma_i \Gamma_j + \Gamma_j \Gamma_i = - 2g_{ij} \mathbf{1},\]</span> 其中<spanclass="math inline">\(\mathbf{1}\)</span>是Clifford代数的单位元。那么Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>可以看做是由<spanclass="math inline">\(\{\Gamma_i\}\)</span>生成的满足上述关系的结合代数<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><spanclass="hint--top hint--rounded"aria-label="这种定义方式不依赖于任何具体表示，类似于李代数中的Universal    enveloping algebra。">[3]</span></a></sup>： <spanclass="math display">\[\textrm{Cl}(V,g) \equiv \frac{\mathbf{1}\oplus V\oplus (V\otimes V) \oplus (V \otimes V \otimes V) +\cdots}{\sim}.\]</span> 由于上述的等价关系，Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>是有限维度的，我们可以如下完全反对称生成元：<span class="math display">\[\Gamma_{i_1 i_2 \cdots i_p} \equiv\frac{1}{p!} \sum_{\sigma \in S_p} (-1)^{\sigma} \Gamma_{i_\sigma(1)}\Gamma_{i_\sigma(2)} \cdots \Gamma_{i_\sigma(p)},\]</span> 其中<spanclass="math inline">\(\sigma\)</span>表示任一排序并且<spanclass="math inline">\((-1)^{\sigma}\)</span>则是这个排序的符号。由此可以看出，Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的生成元为：<spanclass="math inline">\(\mathbf{1},\Gamma_i,\Gamma_{ij},\cdots,\Gamma_{12\cdotsn}\)</span>并且总共的个数为： <spanclass="math display">\[\left(\begin{array}{c} n\\ 0\end{array}\right)+\left(\begin{array}{c} n\\ 1\end{array}\right)+\left(\begin{array}{c} n\\ 2\end{array}\right)+\cdots +\left(\begin{array}{c} n\\ n\end{array}\right) = 2^n.\]</span> 因此Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>是维度为<spanclass="math inline">\(2^{\textrm{dim}(V)}\)</span>的一个线性空间，实际上它也正是<spanclass="math inline">\(V\)</span>的外代数<spanclass="math inline">\(\LambdaV\)</span>所对应的空间，而后者的生成元为：<spanclass="math inline">\(1,e_i,e_i\wedge e_j,\cdots,e_1\wedge e_2\wedge\cdots \wedgee_n\)</span>。当然，这两个代数具有不同的代数结构，从代数的角度上来讲两者并非同构。根据度规<spanclass="math inline">\(g_{ij}\)</span>的号差的不同，Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的结构也不尽相同，以下我们只考虑度规为非退化并且号差为<spanclass="math inline">\((s,t)\)</span>（<spanclass="math inline">\(s\)</span>对应正，<spanclass="math inline">\(t\)</span>对应负），其中<spanclass="math inline">\(s+t =n\)</span>。在不引起混淆的情况下，我们将Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>记为<spanclass="math inline">\(\textrm{Cl}(s,t)\)</span>。</p><h1 id="三维转动群so3与spin3">三维转动群SO(3)与Spin(3)</h1><p>我们首先来看一个例子，即三维的转动群与三维旋量。我们知道三维的转动群SO(3)可以利用四元数表示：如果记三维矢量<spanclass="math inline">\((x,y,z)\)</span>为<span class="math inline">\(x I+ y J + z K\)</span>的话，那么我们可以考虑如下映射： <spanclass="math display">\[R_r(x,y,z) = r \cdot (x I + j J + z K) \cdotr^{-1},\]</span> 其中<spanclass="math inline">\(r\)</span>是一个模长为<spanclass="math inline">\(1\)</span>的四元数：<spanclass="math inline">\(|r| =1\)</span>。这个映射实际上是由单位四元数到三维转动群的一个同态映射：<span class="math display">\[R: S^3 \rightarrow \textrm{SO}(3),\]</span>并且满足Ker(<span class="math inline">\(R\)</span>)=<spanclass="math inline">\(\{ \pm 1 \}\)</span>以及SO(3)<spanclass="math inline">\(\cong S^3 /\{1,-1\}\)</span>。具体来讲，如果我们记<span class="math inline">\(r = a+ b I + c J + d K\)</span>的话（<span class="math inline">\(a^2 + b^2 +c^2 + d^2 = 1\)</span>），那么转动轴与三维矢量<spanclass="math inline">\((b,c,d)\)</span>同方向，并且转动的角度为<spanclass="math inline">\(\theta = 2 \cos^{-1}(a)\)</span>，并且<spanclass="math inline">\(r\)</span>与<spanclass="math inline">\(-r\)</span>代表相同的转动。</p><p>上述的四元数结构实际上与Clliford代数有一个对应的关系，不难发现如果我们利用泡利矩阵<spanclass="math inline">\(\{i \sigma^1, i \sigma^2, i\sigma^3\}\)</span>来代替<spanclass="math inline">\(\{I,J,K\}\)</span>的话，它们两者满足完全相同的代数结构。此时<spanclass="math inline">\(r\)</span>可以利用泡利矩阵记为： <spanclass="math display">\[r = a + i \vec{r}\cdot \vec{\sigma}\]</span>并且满足<span class="math inline">\(rr^{\dagger} =\mathbf{1}\)</span>。这个实际上正是一个最一般的SU(2)=Spin(3)矩阵，也就是说上述映射<spanclass="math inline">\(R\)</span>实际上是从SU(2)到SO(3)的一个映射： <spanclass="math display">\[R : \textrm{Spin(3)} \rightarrow\textrm{SO(3)}.\]</span> 利用类似的观点，我们可以系统地定义<spanclass="math inline">\(\textrm{Pin}(V)\)</span>群和<spanclass="math inline">\(\textrm{Spin}(V)\)</span>群以及它们分别与正交群<spanclass="math inline">\(\textrm{O}(V)\)</span>以及特殊正交群<spanclass="math inline">\(\textrm{SO}(V)\)</span>之间的映射。</p><h1 id="正交群与pin群">正交群与Pin群</h1><p>对于给定的线性空间<spanclass="math inline">\((V,g)\)</span>，我们按照如下方式定义其上的Pin群：如果我们将<spanclass="math inline">\(V\)</span>作为子空间嵌入到Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的中（也就是说矢量的基底是<spanclass="math inline">\(\{\Gamma_i\}\)</span>），那么线性空间<spanclass="math inline">\((V,g)\)</span>所对应的Pin群Pin<spanclass="math inline">\((V)\)</span>定义为<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的一个由所有<spanclass="math inline">\(v\equiv v^i \Gamma_i\in V \subset\textrm{Cl}(V,g)\)</span>并且满足<span class="math inline">\(v^2\equivv^i v^j \Gamma_i \Gamma_j = - g(v,v) \mathbf{1} = \pm\mathbf{1}\)</span>的元素在代数乘法的意义下所生成的子群。换句话说，任何一个Pin(<spanclass="math inline">\(V\)</span>)的元素都可以写为<spanclass="math inline">\(v_1 \cdots v_r\)</span>的形式，其中<spanclass="math inline">\(u_r\in V\)</span>并且满足<spanclass="math inline">\(u_r^2 = \pm \mathbf{1}\)</span>。如果度规<spanclass="math inline">\(g\)</span>的号差为<spanclass="math inline">\((s,t)\)</span>的话，那么在不引起混淆的情况下，我们可以记对应线性空间<spanclass="math inline">\((V,g)\)</span>的Pin群为Pin<spanclass="math inline">\((s,t)\)</span>。特别地，对于欧式空间的话我们直接记Pin<spanclass="math inline">\((n,0)\)</span>为Pin<spanclass="math inline">\((n)\)</span>。</p><p>对于给定的<span class="math inline">\(v \in V \subset\textrm{Cl}(V,g)\)</span>，我们记<span class="math inline">\(v^{-1} =-v^i\Gamma_i/g(v,v)\)</span>为<spanclass="math inline">\(v\)</span>的逆。那么根据上一章节的讨论，我们可以定义一个（扭曲的）伴随映射Ad<spanclass="math inline">\(_v : V \rightarrow V\)</span>为： <spanclass="math display">\[\textrm{Ad}_v (x) = -v x v^{-1} \equiv -(v^i\Gamma_i) (x^j \Gamma_j) \left(\left(v^{-1}\right)^k\Gamma_k\right),\]</span> 利用上述<spanclass="math inline">\(v^{-1}\)</span>的表达式，经过一些简单运算进一步有：<span class="math display">\[\textrm{Ad}_v (x) = x^i \Gamma_i - \frac{2g(x,v)}{g(v,v)} v^i \Gamma_i = x - \frac{2 g(x,v)}{g(v,v)} v =R_v(x),\]</span> 其中<spanclass="math inline">\(R_v\)</span>表示以垂直于矢量<spanclass="math inline">\(v\)</span>的超平面作为镜面的反射。之所以在上述的伴随映射里加一个负号是因为我们最后希望得到的是<spanclass="math inline">\(R_v\)</span>而不是<spanclass="math inline">\(-R_v\)</span>。注意到对于任何一个实数<spanclass="math inline">\(\lambda\)</span>而言<spanclass="math inline">\(R_v=R_{\lambdav}\)</span>，因此不失一般性我们可以令<span class="math inline">\(v^2 =\pm 1\)</span>，也就是说<span class="math inline">\(v\in\textrm{Pin}(V)\)</span>。那么对于Pin<spanclass="math inline">\((V)\)</span>中的任何一个元素<spanclass="math inline">\(v_1 \cdotsv_p\)</span>我们可以将上述伴随映射Ad<spanclass="math inline">\(_v\)</span>扩展为：Ad<spanclass="math inline">\(_{v_1 \cdots v_p} = \textrm{Ad}_{v_1} \circ \cdots\circ \textrm{Ad}_{v_p} = R_{v_1} \circ \cdots \circR_{v_p}\)</span>即一系列反射群的乘积。而反射群属于正交群O<spanclass="math inline">\((V)\)</span>，因此我们就得到了从Pin(<spanclass="math inline">\(V\)</span>)群到正交群O<spanclass="math inline">\((V)\)</span>群的一个映射：<spanclass="math inline">\(\textrm{Ad}:\textrm{Pin}(V) \rightarrow\textrm{O}(V)\)</span>。事实上，任何一个正交群里的元素<spanclass="math inline">\(g\in\textrm{O}(V)\)</span>总可以写为一系列反射元素的组合<spanclass="math inline">\(g=R_{v_1}\circ \cdots \circR_{v_p}\)</span>并且<span class="math inline">\(p \leq\textrm{dim}(V)\)</span>（Cartan-Dieuonn<spanclass="math inline">\(\acute{\textrm{e}}\)</span>），因此上述映射是一个满射。</p><p>接下来我们考虑这个伴随映射的核Ker(Ad)。如果<spanclass="math inline">\(a\in\textrm{Ker}(\textrm{Ad})\)</span>的话，那么根据定义我们有Ad<spanclass="math inline">\(_a(x) = x\)</span>并且对于任意的<spanclass="math inline">\(x\inV\)</span>成立，我们在此处直接给出结论而不加以证明，结论是：Ker(Ad)=<spanclass="math inline">\(\{\mathbf{1},-\mathbf{1}\}\)</span>。</p><p>所有上述结果可以总结为如下的一个exact sequence: <spanclass="math display">\[1 \longrightarrow \{ \pm \mathbf{1} \}\longrightarrow \textrm{Pin}(V) \xrightarrow{\textrm{Ad}} \textrm{O}(V)\longrightarrow 1.\]</span></p><h1 id="特殊正交群与spin群">特殊正交群与Spin群</h1><p>Pin<span class="math inline">\((V)\)</span>是Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的一个子群，我们可以进一步地细分这个群。按照<spanclass="math inline">\(\Gamma\)</span>-矩阵的个数，我们可以把Clifford代数<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>分为：<spanclass="math inline">\(\textrm{Cl}(V,g) = \textrm{Cl}_0 (V,g) \oplus\textrm{Cl}_1 (V,g)\)</span>，其中<spanclass="math inline">\(\textrm{Cl}_0 (V,g)\)</span>中只包含偶数个<spanclass="math inline">\(\Gamma\)</span>-矩阵（包括单位元），而<spanclass="math inline">\(\textrm{Cl}_1 (V,g)\)</span>中则只包含奇数个<spanclass="math inline">\(\Gamma\)</span>-矩阵。<spanclass="math inline">\(\textrm{Cl}_0 (V,g)\)</span>自身是<spanclass="math inline">\(\textrm{Cl}(V,g)\)</span>的一个封闭子代数，因此我们可以将Pin<spanclass="math inline">\((V)\)</span>群限制在<spanclass="math inline">\(\textrm{Cl}_0 (V,g)\)</span>中从而定义Spin<spanclass="math inline">\((V)\)</span>群： <spanclass="math display">\[\textrm{Spin}(V) \equiv \textrm{Pin}(V) \bigcap\textrm{Cl}_0 (V,g).\]</span> 由于Pin<spanclass="math inline">\((V)\)</span>中的任何一个元素<spanclass="math inline">\(v\)</span>可以写为<spanclass="math inline">\(v_1\circ \cdots \circ v_p\)</span>，其中<spanclass="math inline">\(v_p \in V\)</span>，也就是说如果<spanclass="math inline">\(v\)</span>同时属于<spanclass="math inline">\(\textrm{Spin}(V)\)</span>的话，那么<spanclass="math inline">\(p\)</span>则必须为偶数。那么对应的伴随表示下的像<spanclass="math inline">\(\textrm{Ad}_v = R_{v_1} \circ \cdots \circR_{v_p}\)</span>则必须包含偶数个反射元素。由于反射作为正交矩阵的话行列式为<spanclass="math inline">\(-1\)</span>，因此我们必然有<spanclass="math inline">\(\det (\textrm{Ad}_v) = +1\)</span>，因此<spanclass="math inline">\(\textrm{Ad}_v \in\textrm{SO}(V)\)</span>。同样上述结果可以总结为如下的一个exact sequence:<span class="math display">\[1 \longrightarrow \{ \pm \mathbf{1} \}\longrightarrow \textrm{Spin}(V) \xrightarrow{\textrm{Ad}}\textrm{SO}(V) \longrightarrow 1.\]</span></p><p>实际上，物理上我们知道对于Spin群的任何一个元素<spanclass="math inline">\(g\)</span>总可以写为： <spanclass="math display">\[g = \exp \left( \frac{i}{2} \omega^{\mu \nu}S_{\mu \nu} \right),\]</span> 其中<span class="math inline">\(S_{\mu\nu} = i\left[ \Gamma_i,\Gamma_j\right]/4\)</span>为Spin群的生成元，因此把指数展开后，我们可以看到的确只涉及偶数个<spanclass="math inline">\(\Gamma\)</span>-矩阵。而对于Pin群的话，除了上述元素外，单独的<spanclass="math inline">\(\Gamma\)</span>-矩阵也需要考虑进来，因此群的规模相比Spin群要大一些。</p><h1 id="流形的定向与非定向">流形的定向与非定向</h1><p>这一章我们将进入主题，讨论光滑流形上定向问题（第一类Stiefel-Whitney类）以及自旋结构（Pin或者Spin结构，根据流形是否可定向），这一章节我们首先考虑前者。首先我们考虑任一光滑的<spanclass="math inline">\(n\)</span>维流形<spanclass="math inline">\(M\)</span>，选择一组开覆盖U<spanclass="math inline">\(_{\alpha}\)</span>以及坐标<spanclass="math inline">\(\Phi_{\alpha}\)</span>，我们记为一个图册（Atlas）<spanclass="math inline">\(\{\textrm{U}_{\alpha},\Phi_{\alpha}\}\)</span>，不同开集之间的转换函数（transitionfunction）为： <span class="math display">\[g_{\alpha \beta} =\Phi_{\alpha} \circ \Phi^{-1}_{\beta}: \Phi_{\beta}(\textrm{U}_{\alpha\beta}) \rightarrow \Phi_{\alpha}(\textrm{U}_{\alpha \beta}),\]</span>其中U<span class="math inline">\(_{\alpha \beta} := \textrm{U}_{\alpha}\cap\textrm{U}_{\beta}\)</span>。一般来讲转换函数隶属于一般线性群GL(<spanclass="math inline">\(n,\mathbb{R}\)</span>)，但是对于一个配备有度规的黎曼流形<spanclass="math inline">\((M,g)\)</span>，我们总可以调整上述坐标，是的转换函数隶属于正交群O<spanclass="math inline">\((s,t)\)</span>，其中<spanclass="math inline">\(n=s+t\)</span>而<spanclass="math inline">\(s\)</span>和<spanclass="math inline">\(t\)</span>则是度规的号差。</p><p>对于黎曼流形<spanclass="math inline">\((M,g)\)</span>，我们可以谈及这个流形是否是可定向的，也就是说可不可以找到一组坐标<spanclass="math inline">\(\{\Phi_{\alpha}\}\)</span>使得转换函数<spanclass="math inline">\(\{g_{\alpha \beta}\}\)</span>属于特殊正交群SO<spanclass="math inline">\((s,t)\)</span>，如果可以办到的话，我们就说流形是可定向的（orientable），反之则是不可定向的。为了探讨这一点，我们引入<spanclass="math inline">\(\{f_{\alpha \beta}\}\)</span>： <spanclass="math display">\[f_{\alpha \beta}(m) = \det g_{\alpha\beta}(m),\quad \forall m\in \textrm{U}_{\alpha\beta},\]</span>对于正交群我们总有<span class="math inline">\(f_{\alpha \beta} = \pm1\)</span>，因此<span class="math inline">\(f_{\alpha \beta}\)</span>可以看做是<spanclass="math inline">\(\mathbb{Z}_2\)</span>取值的。对于转换函数<spanclass="math inline">\(\{g_{\alpha\beta}\}\)</span>而言，它必须满足如下的cocycle条件： <spanclass="math display">\[g_{\alpha \beta}(m) g_{\beta \gamma}(m) g_{\gamma\alpha}(m) = 1,\quad \forall m \in \textrm{U}_{\alpha} \cap\textrm{U}_{\beta} \cap \textrm{U}_{\gamma},\]</span> 因此<spanclass="math inline">\(\{f_{\alpha\beta}\}\)</span>也自然而然满足cocycle条件： <spanclass="math display">\[f_{\alpha \beta}(m) f_{\beta \gamma}(m) f_{\gamma\alpha}(m) = 1,\quad \forall m \in \textrm{U}_{\alpha}\cap\textrm{U}_{\beta} \cap \textrm{U}_{\gamma}.\]</span> 由于<spanclass="math inline">\(f_{\alpha \beta}\)</span>是<spanclass="math inline">\(\mathbb{Z}_2\)</span>取值的，如果我们记<spanclass="math inline">\(\mathbb{Z}_2 ={0,1}\)</span>并且满足如下环加法关系： <spanclass="math display">\[0+0=0,\quad 0+1=1+0=1,\quad 1+1=0,\]</span>那么上述cocycle条件可以写为： <span class="math display">\[\label{f}    f_{\alpha \beta}(m) - f_{\alpha \gamma}(m) + f_{\beta \gamma}(m) =0,\quad \forall m \in \textrm{U}_{\alpha}\cap \textrm{U}_{\beta} \cap\textrm{U}_{\gamma}.\]</span> 之后对于<spanclass="math inline">\(f_{\alpha\beta}\)</span>而言，我们将交互地使用<spanclass="math inline">\(\mathbb{Z}_2 = \{1,-1\}\)</span>或者<spanclass="math inline">\(\mathbb{Z}_2 =\{0,1\}\)</span>两种语言，前者的乘法则是后者的环加法。由<a href="#f"data-reference-type="eqref"data-reference="f">[f]</a>我们可以看出，<spanclass="math inline">\(\{f_{\alpha \beta}\}\)</span>实际上是<spanclass="math inline">\(\mathbb{Z}_2\)</span>取值的C<spanclass="math inline">\(\check{\textrm{e}}\)</span>ch上同调群的一个cocycle：<span class="math display">\[\{f_{\alpha \beta}\} \in\textrm{H}^1(M,\mathbb{Z}_2),\]</span> 并且我们称之为黎曼流形<spanclass="math inline">\((M,g)\)</span>的第一类Stiefel-Whitney类（The firstStiefel-Whitney class）。而流形可不可定向取决于<spanclass="math inline">\(\{f_{\alpha\beta}\}\)</span>是否是一个coboundary，也就是说<spanclass="math inline">\(f_{\alpha \beta}\)</span>是否可以写成： <spanclass="math display">\[f_{\alpha \beta}(m) = f_{\alpha}(m) -f_{\beta}(m), \quad \forall m \in \textrm{U}_{\alpha}\cap\textrm{U}_{\beta},\]</span> 或者如果用<spanclass="math inline">\(\mathbb{Z}_2 =\{1,-1\}\)</span>的理解方式的话，上述关系为<spanclass="math inline">\(f_{\alpha \beta}(m) = f_{\alpha}(m)f^{-1}_{\beta}(m)\)</span>。如果<span class="math inline">\(\{f_{\alpha\beta}\}\)</span>的确是一个coboundary的话，那么我们就可以定义一组新的坐标<spanclass="math inline">\(\Phi&#39;_{\alpha} = g_{\alpha} \circ\Phi_{\alpha}\)</span>，其中<spanclass="math inline">\(\{g_{\alpha}\}\)</span>为任意的满足<spanclass="math inline">\(\det g_{\alpha} =f_{\alpha}\)</span>的正交群元素。那么新的转换函数为： <spanclass="math display">\[g&#39;_{\alpha \beta} = \Phi&#39;_{\alpha} \circ\Phi&#39;^{-1}_{\beta}=g_{\alpha} \circ g_{\alpha \beta} \circg_{\beta}^{-1},\]</span> 并且满足： <spanclass="math display">\[\begin{aligned}    \det g&#39;_{\alpha \beta} &amp;= \det g_{\alpha} \det g_{\alpha\beta} \det g^{-1}_{\beta}\nonumber \\ &amp;= f_{\alpha}\cdot f_{\alpha\beta}\cdot f^{-1}_{\beta} \nonumber \\ &amp;=f^2_{\alpha}\cdotf^{-2}_{\beta} = 1,\end{aligned}\]</span>由此我们可以看出，转换函数可以化为正交群的元素，因此按照定义为可定向的。反之，如果<spanclass="math inline">\((M,g)\)</span>为可定向的流形，那么我们可以证明<spanclass="math inline">\(\{f_{\alpha\beta}\}\)</span>为平凡的，自然是一个coboundary。总结来说，一个流形是否可以定向，取决于它的第一类Stiefel-Whitney类是否为平凡的。</p><h1 id="流形的自旋结构">流形的自旋结构</h1><p>最后一章我们将讨论光滑流形的自旋结构。如果我们要谈论自旋结构（Pin或者Spin结构），我们首先要将不同开集之间的转换函数<spanclass="math inline">\(\{g_{\alpha \beta}\}\)</span>提升为<spanclass="math inline">\(\{ \tilde{g}_{\alpha \beta}\}\)</span>，而后者则属于Pin<spanclass="math inline">\((s,t)\)</span>或者Spin<spanclass="math inline">\((s,t)\)</span>，根据流形是否为可定向流形，或者第一类Stiefel-Whitney类是否为平凡的。</p><p>具体来言，我们考虑<span class="math inline">\(\{g_{\alpha \beta} \in\textrm{O}(s,t)\}\)</span>的一个提升<spanclass="math inline">\(\{\tilde{g}_{\alpha \beta} \in\textrm{Pin}(s,t)\}\)</span>，并且根据Pin群与正交群的关系，后者需要满足：<span class="math display">\[\textrm{Ad}_{\tilde{g}_{\alpha \beta}} =g_{\alpha \beta},\]</span> 其中<span class="math inline">\(\textrm{Ad} :\textrm{Pin}(s,t) \rightarrow\textrm{O}(s,t)\)</span>是在之前定义的伴随映射。同时，<spanclass="math inline">\(\{\tilde{g}_{\alpha\beta}\}\)</span>作为转换函数则还需要满足cocycle条件： <spanclass="math display">\[\tilde{g}_{\alpha \beta}(m) \tilde{g}_{\beta\gamma}(m) \tilde{g}_{\gamma \alpha}(m) = 1,\quad \forall m \in\textrm{U}_{\alpha} \cap \textrm{U}_{\beta} \cap\textrm{U}_{\gamma}.\]</span>但实际上，上述条件不一定满足。如果我们对左式做伴随映射的话，那么我们有：<span class="math display">\[\textrm{Ad}_{\tilde{g}_{\alpha \beta}\tilde{g}_{\beta \gamma} \tilde{g}_{\gamma \alpha}} = g_{\alpha \beta}g_{\beta \gamma} g_{\gamma \alpha} = 1,\]</span> 因此: <spanclass="math display">\[\tilde{g}_{\alpha \beta}(m) \tilde{g}_{\beta\gamma}(m) \tilde{g}_{\gamma \alpha}(m) \in \textrm{Ker}(\textrm{Ad}) =\{1,-1\}.\]</span> 因此我们定义： <spanclass="math display">\[\tilde{f}_{\alpha \beta \gamma}(m) =\tilde{g}_{\alpha \beta}(m) \tilde{g}_{\beta \gamma}(m)\tilde{g}_{\gamma \alpha}(m) \in \textrm{Ker}(\textrm{Ad}) =\{1,-1\},\]</span> 如果<span class="math inline">\(\tilde{f}_{\alpha\beta \gamma} = 1\)</span>的话，那么我们说<spanclass="math inline">\((M,g)\)</span>可以允许一个Pin结构。对于<spanclass="math inline">\(\{\tilde{f}_{\alpha \beta\gamma}\}\)</span>而言，由于它也是<spanclass="math inline">\(\mathbb{Z}_2\)</span>取值的，我们可以将它看做C<spanclass="math inline">\(\check{\textrm{e}}\)</span>ch上同调群的一个cochain，并且经过一系列运算我们可以得知它满足如下的关系：<span class="math display">\[(\delta f)_{\alpha \beta \gamma \delta}\equiv \tilde{f}_{\alpha \beta \gamma}(m) \tilde{f}^{-1}_{\alpha \beta\delta}(m) \tilde{f}_{\alpha \gamma \delta}(m) \tilde{f}^{-1}_{\beta\gamma \delta}(m) = 1,\]</span> 对于任何的<spanclass="math inline">\(m\in \textrm{U}_{\alpha} \cap \textrm{U}_{\beta}\cap \textrm{U}_{\gamma} \cap\textrm{U}_{\delta}\)</span>，也就是说<spanclass="math inline">\(\{\tilde{f}_{\alpha \beta\gamma}\}\)</span>是一个<spanclass="math inline">\(\mathbb{Z}_2\)</span>取值的C<spanclass="math inline">\(\check{\textrm{e}}\)</span>ch上同调群的一个cocycle：<span class="math display">\[\{\tilde{f}_{\alpha \beta \gamma}\} \in\textrm{H}^2(M,\mathbb{Z}_2),\]</span> 并且我们称之为黎曼流形<spanclass="math inline">\((M,g)\)</span>的第二类Stiefel-Whitney类（Thesecond Stiefel-Whitney class）。如果<spanclass="math inline">\(\{\tilde{f}_{\alpha \beta\gamma}\}\)</span>是一个coboundary的话，那么我们总可以有： <spanclass="math display">\[\tilde{f}_{\alpha \beta \gamma}(m) =\tilde{f}_{\alpha \beta}(m) \tilde{f}^{-1}_{\alpha \gamma}(m)\tilde{f}_{\beta \gamma}(m),\quad \forall m\in \textrm{U}_{\alpha} \cap\textrm{U}_{\beta} \cap \textrm{U}_{\gamma},\]</span>因此我们可以定义<span class="math inline">\(g&#39;_{\alpha \beta} =\tilde{f}_{\alpha \beta} \tilde{g}_{\alpha \beta} \in\textrm{Pin}(s,t)\)</span>，使得新的转移函数同时满足： <spanclass="math display">\[\textrm{Ad}_{g&#39;_{\alpha \beta}} = g_{\alpha\beta},\]</span> 以及 <span class="math display">\[g&#39;_{\alpha\beta}(m) g&#39;_{\beta \gamma}(m) g&#39;_{\gamma \alpha}(m) = 1,\quad\forall m \in \textrm{U}_{\alpha} \cap \textrm{U}_{\beta} \cap\textrm{U}_{\gamma},\]</span> 因此<spanclass="math inline">\((M,g)\)</span>允许一个Pin结构。反过来说，如果<spanclass="math inline">\((M,g)\)</span>允许一个Pin结构的话，那么可以证明<spanclass="math inline">\(\{\tilde{f}_{\alpha \beta\gamma}\}\)</span>是一个平凡的coboundary。总结来说，一个流形是否允许一个Pin结构，取决于它的第二类Stiefel-Whitney类是否为平凡的。</p><p>如果流形<spanclass="math inline">\((M,g)\)</span>是可定向流形，也就是第一类Stiefel-Whitney类是平凡的话，那么流行上是否可以定义一个Spin结构同样取决于第二类Stiefel-Whitney类是否为平凡的。但是一个流形上可以选择的自旋结构并不唯一，如果我们选取<spanclass="math inline">\(\{\tilde{g}_{\alpha\beta}\}\)</span>为一组自旋结构的话，对于流形上任意一个<spanclass="math inline">\(\textrm{Ker}(Ad) =\mathbb{Z}_2\)</span>取值的cocycle<spanclass="math inline">\(\{f_{\alpha \beta}\}\in\textrm{H}^1(M,\mathbb{Z}_2)\)</span>，我们都可以定义新的转换函数<spanclass="math inline">\(g&#39;_{\alpha \beta} \equiv f_{\alpha}\tilde{g}_{\alpha \beta} \in \textrm{Spin}(s,t)\)</span>使得它同时满足：<span class="math display">\[\textrm{Ad}_{g&#39;_{\alpha \beta}} =g_{\alpha \beta} \in \textrm{SO}(s,t),\]</span> 以及 <spanclass="math display">\[g&#39;_{\alpha \beta}(m) g&#39;_{\beta \gamma}(m)g&#39;_{\gamma \alpha}(m) = 1,\quad \forall m \in \textrm{U}_{\alpha}\cap \textrm{U}_{\beta} \cap \textrm{U}_{\gamma}.\]</span>我们需要问的是，新的转换函数<span class="math inline">\(\{g&#39;_{\alpha\beta}\}\)</span>和原来的转换函数<span class="math inline">\(\{g_{\alpha\beta}\}\)</span>是不是等价的，这实际上取决于<spanclass="math inline">\(\{f_{\alpha \beta}\}\in\textrm{H}^1(M,\mathbb{Z}_2)\)</span>是不是平凡的。如果<spanclass="math inline">\(\{f_{\alpha\beta}\}\)</span>是平凡的，也就是说我们有<spanclass="math inline">\(f_{\alpha \beta} = f_{\alpha}f^{-1}_{\beta}\)</span>，那么这样的话，通过一组坐标变换<spanclass="math inline">\(\tilde{\Phi}&#39;_{\alpha} = f_{\alpha}\tilde{\Phi}_{\alpha}\)</span>我们可以把两个转换函数设为一样的，因此它们是等价的。这里<spanclass="math inline">\(\Phi&#39;_{\alpha}\)</span>是自旋丛Spin<spanclass="math inline">\((M)\)</span>的平凡化（trivilization）。另一方面，如果<spanclass="math inline">\(\{f_{\alpha\beta}\}\)</span>是非平凡的，那么新的转换函数<spanclass="math inline">\(\{g&#39;_{\alpha\beta}\}\)</span>则给出了另外一种不等价的自旋结构。实际上我们有同构关系<spanclass="math inline">\(\textrm{H}^1(M,\mathbb{Z}_2) \cong\textrm{Hom}(\pi_1(M),\mathbb{Z}_2)\)</span>，也就是说自旋结构通常取决于流形上有多少不可收缩的1-cycle（圆环），如果有<spanclass="math inline">\(g\)</span>个的话，那么我们对于每个不可收缩的1-cycle可以选择<spanclass="math inline">\(\pm\)</span>两种不同的自旋结构，因此总的自旋结构有<spanclass="math inline">\(2^g\)</span>种。一个例子就是对于圆环面，我们一共有四种不同的自旋结构，在弦论中分别被称为:R-R、R-NS、NS-R、NS-NS。</p><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>Clifford代数是结合代数。<a href="#fnref:1" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:2"class="footnote-text"><span>注意这里的约定和很多理论物理书籍里的约定并不相同，双方的<spanclass="math inline">()</span>矩阵差一个虚数<spanclass="math inline">(i)</span>。<a href="#fnref:2" rev="footnote" class="footnote-backref">↩︎</a></span></span></li><li><span id="fn:3"class="footnote-text"><span>这种定义方式不依赖于任何具体表示，类似于李代数中的Universalenveloping algebra。<a href="#fnref:3" rev="footnote" class="footnote-backref">↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;clifford代数&quot;&gt;Clifford代数&lt;/h1&gt;
&lt;p&gt;在讲自旋之前，我们首先需要关于Clifford代数的一些基本知识。Clifford代数的定义大致有两种，一种是比较抽象的偏数学的定义，在这里我们并不打算讨论这种抽象的定义方式。另外一种是比较具体的，或者说是比较物理的定义，最早是由狄拉克给出的并且仍然在所有量子场论的教科书中使用的定义方式，我们这里将采取这种。</summary>
    
    
    
    <category term="Math" scheme="https://quantum-cyborg.github.io/categories/Math/"/>
    
    
    <category term="Algebraic Geometry" scheme="https://quantum-cyborg.github.io/tags/Algebraic-Geometry/"/>
    
  </entry>
  
  <entry>
    <title>翼装飞行，是人类的黄金精神！</title>
    <link href="https://quantum-cyborg.github.io/2021/07/09/Others/Wingsuit%20Skydiving/"/>
    <id>https://quantum-cyborg.github.io/2021/07/09/Others/Wingsuit%20Skydiving/</id>
    <published>2021-07-09T05:21:53.000Z</published>
    <updated>2023-12-24T16:20:19.260Z</updated>
    
    <content type="html"><![CDATA[<p>飞行，是人类的终极梦想。被重力束缚在大地上的生物，只有借着飞行才能够超越这种重负。能够不顾生死而完成这种梦想的人，是真正的勇士！是人类的黄金精神！！<span id="more"></span> <div style="position: relative; width: 100%; height: 0; padding-bottom: 75%;"><iframe src="//player.bilibili.com/player.html?aid=931484287&bvid=BV1FM4y1M7Kr&cid=361399480&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" style="position: absolute; width: 100%; height: 100%; Left: 0; top: 0;" ></iframe></div></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;飞行，是人类的终极梦想。
被重力束缚在大地上的生物，只有借着飞行才能够超越这种重负。
能够不顾生死而完成这种梦想的人，是真正的勇士！是人类的黄金精神！！</summary>
    
    
    
    <category term="Others" scheme="https://quantum-cyborg.github.io/categories/Others/"/>
    
    
  </entry>
  
  <entry>
    <title>霍普夫映射与四元数</title>
    <link href="https://quantum-cyborg.github.io/2021/07/09/Math/Hopf/"/>
    <id>https://quantum-cyborg.github.io/2021/07/09/Math/Hopf/</id>
    <published>2021-07-08T18:00:53.000Z</published>
    <updated>2023-12-24T16:20:58.548Z</updated>
    
    <content type="html"><![CDATA[<h1 id="霍普夫映射hopf-map">霍普夫映射(Hopf map)</h1><p>霍普夫映射是一个四维球面到三维球面的一个映射<spanclass="math inline">\(h:S^3 \rightarrow S^2\)</span>满足： <spanclass="math display">\[h(a,b,c,d) = (a^2 + b^2 -c^2 -d^2 , 2(ad +bc),2(bd - ac)),\]</span> 其中<spanclass="math inline">\((a,b,c,d)\)</span>是四维单位球面上的坐标，满足<spanclass="math inline">\(a^2 + b^2 + c^2 + d^2 =1\)</span>，<span id="more"></span>并且不难验证作为像的三维坐标<spanclass="math inline">\((a^2 + b^2 -c^2 -d^2 , 2(ad +bc), 2(bd -ac))\)</span>同样是位于三维单位球面上的。为了更好地理解霍普夫映射以及霍普夫纤维化，我们需要引入一种更好的刻画四维球面的方法，即所谓的四元数。</p><h1 id="四元数">四元数</h1><p>在四维欧式空间<spanclass="math inline">\(\mathbb{R}^4\)</span>里，考虑任何一个四维矢量<spanclass="math inline">\((a,b,c,d)\)</span>（这里暂不要求是单位矢量），我们可以将其写为：<span class="math display">\[r \equiv a + b I + c J + d K = (a + b I) +(c + d I) J,\]</span> 其中<spanclass="math inline">\(I\)</span>是我们常用的虚数单位，而<spanclass="math inline">\(J,K\)</span>则是另外引入的两个新的虚数单位，它们三者之间满足如下的代数关系：<span class="math display">\[\left\{ \begin{array}{l}I^2 = J^2 = K^2 = -1\\IJ = - JI = K,\\  JK=-KJ = I,\\ KI = -IK = J\end{array} \right.\]</span> 任何一个四元数<span class="math inline">\(r= a + b I + c J + d K\)</span>的复共轭为： <spanclass="math display">\[\bar{r} = a - b I - c J - d K,\]</span> 最后<spanclass="math inline">\(r\)</span>的模长定义为： <spanclass="math display">\[ |r| = \sqrt{a^2 + b^2 + c^2 + d^2} = \sqrt{r\bar{r}}, \]</span> 利用模长，任何一个四元数<spanclass="math inline">\(r\)</span>的倒数可以记为： <spanclass="math display">\[r^{-1} = \frac{\bar{r}}{|r|^2},\]</span>最后值得一提的是，四元数的运算满足结合律，但并不一定满足交换律。</p><p>利用四元数，我们可以考虑三维欧式空间<spanclass="math inline">\(\mathcal{R}^3\)</span>上的一个线性映射。对于三维欧式空间中的任意一个点<spanclass="math inline">\((x,y,z)\)</span>我们可以将其看做一个四元数<spanclass="math inline">\(x I + y J + zK\)</span>。对于任意给定的四元数<spanclass="math inline">\(r\)</span>，我们可以考虑如下映射： <spanclass="math display">\[R_r (x,y,z) = r \cdot (x I + y J + z K)\cdotr^{-1}.\]</span> 接下来我们直接记三维欧式空间中的点<spanclass="math inline">\(x I + y J + z K\)</span>为<spanclass="math inline">\(p\)</span>。这个映射有如下的性质：</p><ul><li><p><span class="math inline">\(R_r\)</span>是一个线性映射。</p></li><li><p><span class="math inline">\(R_r\)</span>保持四元数<spanclass="math inline">\(p\)</span>的模长：<span class="math inline">\(|r pr^{-1}| = |r|\cdot |p| \cdot |r^{-1}| = |p|\)</span>。</p></li><li><p>对于任意实数<span class="math inline">\(u\)</span>，<spanclass="math inline">\(R_{ur} = R_r\)</span>。</p></li></ul><p>从第二点我们可以大致猜测，如果<span class="math inline">\(r\neq0\)</span>的话，我们可以将<spanclass="math inline">\(R_r\)</span>视为三维欧式空间<spanclass="math inline">\(\mathcal{R}^3\)</span>中的一个转动，转动轴和转动角度可以用如下方式确定下来：</p><ul><li><p>首先，我们可以利用<span class="math inline">\(R_{ur} =R_r\)</span>将四元数<spanclass="math inline">\(r\)</span>的模长设置为单位值：<spanclass="math inline">\(|r|=1\)</span>。</p></li><li><p>如果<span class="math inline">\(r=\pm1\)</span>的话，那么很容易看出这个转动是平凡的转动，也就是单位映射。</p></li><li><p>记<span class="math inline">\(r = a + b I + c J + dK\)</span>（我们已经令<span class="math inline">\(a^2 + b^2 + c^2 + d^2= 1\)</span>），转动轴的方向与三维矢量<spanclass="math inline">\((b,c,d)\)</span>同方向，并且转动的角度<spanclass="math inline">\(\theta\)</span>为：<spanclass="math inline">\(\theta = 2 \cos^{-1}(a) = 2 \sin^{-1}\left(\sqrt{a^2 + b^2 + c^2}\right)\)</span>。</p></li></ul><p>实际上，我们可以很容易验证转动轴<spanclass="math inline">\((b,c,d)\)</span>作为一个三维矢量在上述转动下保持不变:<span class="math display">\[R_r (b,c,d) = r \cdot (b I + c J + d K)\cdot r^{-1} = b I + c J + d K.\]</span> 最后，如果<spanclass="math inline">\(r\)</span>和<spanclass="math inline">\(s\)</span>为两个四元数，那么上述映射<spanclass="math inline">\(R\)</span>满足同态关系： <spanclass="math display">\[R_r \circ R_s = R_{rs},\]</span>因此两个转动的叠加可以利用四元数写为两个相应四元数的乘法，这个是利用四元数描述三维转动的简单之处。</p><p>如果读者熟悉群论，那么上述映射<spanclass="math inline">\(R\)</span>实际上可以看作由单位四维球面<spanclass="math inline">\(S^3\)</span>到三维转动群SO(3)上的一个映射： <spanclass="math display">\[R: S^3 \rightarrow \textrm{SO}(3),\]</span>并且这个映射是一个同态映射。映射的核（Kernel）为： <spanclass="math display">\[\textrm{Ker} (R) = \{1,-1\},\]</span>那么由同态映射的基本定理，转动群SO(3)可以写为： <spanclass="math display">\[\textrm{SO}(3) \cong S^3 / \{ 1,-1\},\]</span>实际上这也正是三维的实投影平面<spanclass="math inline">\(\mathbb{R}\mathbb{P}_3\)</span>。这个就是SO(3)群作为一个流形的拓扑结构。</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;霍普夫映射hopf-map&quot;&gt;霍普夫映射(Hopf map)&lt;/h1&gt;
&lt;p&gt;霍普夫映射是一个四维球面到三维球面的一个映射&lt;span
class=&quot;math inline&quot;&gt;\(h:S^3 \rightarrow S^2\)&lt;/span&gt;满足： &lt;span
class=&quot;math display&quot;&gt;\[h(a,b,c,d) = (a^2 + b^2 -c^2 -d^2 , 2(ad +bc),
2(bd - ac)),\]&lt;/span&gt; 其中&lt;span
class=&quot;math inline&quot;&gt;\((a,b,c,d)\)&lt;/span&gt;是四维单位球面上的坐标，满足&lt;span
class=&quot;math inline&quot;&gt;\(a^2 + b^2 + c^2 + d^2 =
1\)&lt;/span&gt;，</summary>
    
    
    
    <category term="Math" scheme="https://quantum-cyborg.github.io/categories/Math/"/>
    
    
    <category term="Algebraic Geometry" scheme="https://quantum-cyborg.github.io/tags/Algebraic-Geometry/"/>
    
    <category term="Hopf" scheme="https://quantum-cyborg.github.io/tags/Hopf/"/>
    
  </entry>
  
  <entry>
    <title>SOS Model</title>
    <link href="https://quantum-cyborg.github.io/2021/06/28/Physics/SOS%20Model/"/>
    <id>https://quantum-cyborg.github.io/2021/06/28/Physics/SOS%20Model/</id>
    <published>2021-06-28T05:18:00.000Z</published>
    <updated>2023-12-30T15:20:34.214Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Model</strong></p><p><span class="math display">\[H_{S O S}=\sum_{\langle x, y\rangle}V\left(\left|h_{x}-h_{y}\right|\right)\]</span> where <spanclass="math inline">\(h_{x}\)</span> is integer.</p><span id="more"></span><ul><li><p>Absolute value SOS model <span class="math display">\[H_{A S O S}=\beta_{A S O S} \sum_{\langle x,y\rangle}\left|h_{x}-h_{y}\right|\]</span></p></li><li><p>Discrete Gaussian SOS model (dual of the Villian model): <spanclass="math display">\[H_{D G S O S}=\frac{\beta_{D G S O S}}{2} \sum_{\langle x, y\rangle}\left(h_{x}-h_{y}\right)^{2}\]</span> looks exactly like the continuous Gaussian model, thedifference is that <span class="math inline">\(h_x\)</span> is integervalues introduces a nontrivial interaction.</p></li><li><p>Body Centered Solid-On-Solid (BCSOS) or F-model <spanclass="math display">\[H_{BCSOS}=K^{BCSOS} \sum_{[x, y]} \left| h_{x}-h_{y} \right|\]</span> a 2D lattice splits in two sublattices. spins on “odd” latticesites take values of the form <span class="math inline">\(2n +1/2\)</span> , and spins on “even” sites are of the form <spanclass="math inline">\(2n − 1/2\)</span>, <spanclass="math inline">\(n\)</span> integer. The nearest neighbour spins<span class="math inline">\(h_x\)</span> and <spanclass="math inline">\(h_y\)</span> obey the constraint <spanclass="math inline">\(|h_x − h_y|=1\)</span>.</p></li></ul><hr /><p><strong>General Picture</strong></p><p>For finite positive <span class="math inline">\(K\)</span></p><ul><li>smooth phase: <span class="math inline">\(K\)</span> is largeenough, all <span class="math inline">\(h\)</span> tends to be same, thefluctuation is very small.</li><li>critical value:</li><li>rough:</li></ul><hr /><ul><li><p>Strong coupling are mapped to weak couplings and viceversa.</p></li><li><p>discrete height variables : the height of a crystal surface(measured in atoms)</p></li><li><p>2D: BCSOS or (in yet another guise) the 6-vertexmodel</p></li></ul><hr /><p><strong>XY model with Villain action</strong></p><p><span class="math display">\[Z_{V}=\int_{-\pi}^{\pi} \prod_{x} d \Theta_{x} \prod_{&lt;x, y&gt;}B\left(\Theta_{x}-\Theta_{y}\right)\]</span> with <span class="math display">\[B(\Theta ) = \sum_{p=-\infty}^{\infty} \exp \left(-\frac{1}{2}\beta_{V}(\Theta-2 \pi p)^{2}\right)\]</span></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;Model&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;math display&quot;&gt;\[H_{S O S}=\sum_{\langle x, y\rangle}
V\left(\left|h_{x}-h_{y}\right|\right)\]&lt;/span&gt; where &lt;span
class=&quot;math inline&quot;&gt;\(h_{x}\)&lt;/span&gt; is integer.&lt;/p&gt;</summary>
    
    
    
    <category term="Physics" scheme="https://quantum-cyborg.github.io/categories/Physics/"/>
    
    
    <category term="Statistic Physics" scheme="https://quantum-cyborg.github.io/tags/Statistic-Physics/"/>
    
  </entry>
  
  <entry>
    <title>Torque PBS系统的安装</title>
    <link href="https://quantum-cyborg.github.io/2021/04/03/CS/cluster/Torque%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <id>https://quantum-cyborg.github.io/2021/04/03/CS/cluster/Torque%E7%9A%84%E5%AE%89%E8%A3%85/</id>
    <published>2021-04-02T16:00:00.000Z</published>
    <updated>2023-12-24T16:22:08.566Z</updated>
    
    <content type="html"><![CDATA[<p>帮同学在小集群上安装了TorquePBS系统，简要地记录了一些的安装的过程。但是当时急匆匆的，很多细节没有记录，这里的记录只作为一个很粗略的笔记。<span id="more"></span> ----------------------------------</p><h1 id="nfs">NFS</h1><p><code>yum  -y  install  nfs-utils</code><br /><code>systemctl enable nfs</code><br /><code>systemctl restart nfs</code><br /><code>showmount -e 192.168.0.115</code></p><p>修改 /etc/fstab:<br /><code>192.168.0.115:/home/customer  /home/customer nfs defaults,nfsvers=3 0 0</code></p><p>挂载<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home<br><span class="hljs-built_in">mkdir</span> customer<br>mount -a<br>mount<br></code></pre></td></tr></table></figure></p><p>edit /etc/hosts:<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim /etc/hosts<br><span class="hljs-comment"># 192.168.0.125 node06</span><br></code></pre></td></tr></table></figure></p><h1 id="nis">NIS</h1><p><code>yum -y install ypserv ypbind yp-tools rpcbind</code></p><p>cal node:<br /><code>vim /etc/sysconfig/network</code> NISDOMAIN=licluster<br /><code>vim /etc/rc.local</code> nisdomainname licluster<br /><code>vim /etc/yp.conf</code> domain licluster server192.168.0.115<br /><code>nisdomainname licluster</code> / nisdomainname 192.168.0.115</p><p><code>vim /etc/nsswitch.conf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start ypbind.service<br>systemctl start rpcbind.service<br>systemctl <span class="hljs-built_in">enable</span> ypbind.service<br>systemctl <span class="hljs-built_in">enable</span> rpcbind.service<br></code></pre></td></tr></table></figure><p>检查是否启动: <code>ypwhich</code><br />测试用户customer信息: <code>id customer</code><br />检查同步的文件: <code>yptest</code></p><h1 id="ssh免输密码访问基于密钥">ssh免输密码访问:基于密钥</h1><h1 id="ntp客户端">NTP客户端</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">yum -y install ntp ntpdate<br>ntpdate master<br></code></pre></td></tr></table></figure><h1 id="cluster">Cluster</h1><h2 id="主节点上的安装">主节点上的安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">./configure --prefix=/usr/local/torque --with-default-server=<span class="hljs-variable">$HOSTNAME</span><br>make<br>make install<br></code></pre></td></tr></table></figure><blockquote><p>pbs_mom, PBS MOM守护进程，负责监控本机并执行作业，位于所有计算节点上</p><p>pbs_sched, PBS调度守护进程，负责调度作业，位于服务节点上</p><p>pbs_server, PBS服务守护进程，负责接收作业提交，位于服务节点上</p></blockquote><ul><li><p>添加系统服务 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span>  contrib/systemd/trqauthd.service  /usr/lib/systemd/system/<br><span class="hljs-built_in">cp</span>  contrib/systemd/pbs_server.service /usr/lib/systemd/system/<br><span class="hljs-built_in">cp</span>  contrib/systemd/pbs_sched.service  /usr/lib/systemd/system/<br><span class="hljs-built_in">cp</span>  contrib/systemd/pbs_mom.service  /usr/lib/systemd/system/<br></code></pre></td></tr></table></figure></p></li><li><p>添加开机启动<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> pbs_server<br>systemctl <span class="hljs-built_in">enable</span> pbs_sched<br>systemctl <span class="hljs-built_in">enable</span> pbs_mom<br>systemctl <span class="hljs-built_in">enable</span> trqauthd<br></code></pre></td></tr></table></figure></p></li><li><p>Configure Torque on headnode<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> [correct_hostname] &gt; /var/spool/torque/server_name<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;/opt/torque/lib&quot;</span> &gt; /etc/ld.so.conf.d/torque.conf<br>ldconfig<br></code></pre></td></tr></table></figure> adding the information of nodes in/var/spool/torque/server_priv/nodes.<br /><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">node01 <span class="hljs-attribute">np</span>=1<br>node02 <span class="hljs-attribute">np</span>=1<br></code></pre></td></tr></table></figure></p></li><li><p>Initialize serverdb:<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">./torque.setup  root<br>qterm<br></code></pre></td></tr></table></figure></p></li></ul><p>启动<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl start pbs_sched<br>systemctl start pbs_mom<br>systemctl start trqauthd<br>systemctl start pbs_server<br></code></pre></td></tr></table></figure></p><h2 id="计算节点上的安装">计算节点上的安装</h2><p>在解压缩后的目录/opt/src/torque-6.1.2下运行<code>make packages</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /home/customer/software/torque-6.1.2/<br>./torque-package-clients-linux-x86_64.sh  --install<br>./torque-package-devel-linux-x86_64.sh  --install<br>./torque-package-doc-linux-x86_64.sh  --install<br>./torque-package-mom-linux-x86_64.sh  --install<br>./torque-package-server-linux-x86_64.sh  --install<br></code></pre></td></tr></table></figure><p>计算节点配置</p><p><code>/var/spool/torque</code> 下创建一个文件 server_name<br />修改 <code>/var/spool/torque/mom_priv/config</code></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$pbsserver</span>  master  <span class="hljs-comment">#服务端主机名</span><br><span class="hljs-variable">$logevent</span> <span class="hljs-number">255</span>  <span class="hljs-comment">#日志级别</span><br><span class="hljs-variable">$usecp</span>  master:<span class="hljs-regexp">/home/</span>customer  <span class="hljs-regexp">/home/</span>customer  <span class="hljs-comment">#对NFS共享目录采用cp而不是scp复制文件</span><br><span class="hljs-variable">$spool_as_final_name</span>  true<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> pbs_mom.service<br>systemctl start pbs_mom.service<br></code></pre></td></tr></table></figure><h1 id="防火墙">防火墙</h1><p>获取 firewalld 状态 <code>firewall-cmd --state</code><br />列出全部启用的区域的特性<code>firewall-cmd --list-all-zones</code><br />开放端口（开放后需要要重启防火墙才生效）<br /><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --zone=public --add-port=2049/tcp --permanent<br>firewall-cmd --zone=public --add-port=2049/udp --permanent<br>firewall-cmd --zone=public --add-port=15003/tcp --permanent<br>firewall-cmd --zone=public --add-port=15003/udp --permanent<br>firewall-cmd --zone=public --add-port=15002/tcp --permanent<br>firewall-cmd --zone=public --add-port=15002/udp --permanent<br></code></pre></td></tr></table></figure></p><p>重启防火墙 <code>firewall-cmd --reload</code></p><h1 id="change-the-uid">change the uid</h1>]]></content>
    
    
    <summary type="html">&lt;p&gt;帮同学在小集群上安装了Torque
PBS系统，简要地记录了一些的安装的过程。但是当时急匆匆的，很多细节没有记录，这里的记录只作为一个很粗略的笔记。</summary>
    
    
    
    <category term="CS-MISC" scheme="https://quantum-cyborg.github.io/categories/CS-MISC/"/>
    
    
    <category term="PBS" scheme="https://quantum-cyborg.github.io/tags/PBS/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中的NULL、0和nullptr的区别</title>
    <link href="https://quantum-cyborg.github.io/2017/11/10/CS/cpp_rust/NULL%200%20and%20nullptr%20in%20C++/"/>
    <id>https://quantum-cyborg.github.io/2017/11/10/CS/cpp_rust/NULL%200%20and%20nullptr%20in%20C++/</id>
    <published>2017-11-09T16:00:00.000Z</published>
    <updated>2023-12-26T05:39:37.417Z</updated>
    
    <content type="html"><![CDATA[<p>在 <code>C/C++</code> 中，为了防止野指针（指针指向的位置是不可知的），我们常常需要将指针赋值为空指针。在 <code>C</code> 中我们用 <code>NULL</code> 来表示空指针，而在 <code>C++</code> 中则有 <code>NULL</code> 和 <code>nullptr</code> 两种空指针，并且其 <code>NULL</code> 的定义也和 <code>C</code> 语言中的完全不同。我们就在这篇文章中仔细研究一下。 <span id="more"></span></p><h2 id="null">NULL</h2><p>在 <code>C</code> 语言中，我们使用 <code>NULL</code> 来表示空指针。他是一个宏定义，其定义是 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br></code></pre></td></tr></table></figure> 也就是说 <code>NULL</code> 其实是一个 <code>void*</code> 类型的指针。并且在 <code>C</code> 语言中，任何类型的指针都可以（隐式地）转换为 <code>void *</code> 类型，反过来也成立。但是在 <code>C++</code> 中则不存在这种隐式的转换。比如在 <code>C</code> 语言中， <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> *i = (<span class="hljs-type">void</span> *)<span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure> 上述的写法是完全合法的，但是使用 <code>C++</code> 编译器则会报错。在 <code>C++</code> 中 <code>NULL</code> 被定义为整数 <code>0</code> : <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> NULL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __cplusplus</span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL 0</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>        <span class="hljs-meta">#<span class="hljs-keyword">define</span> NULL ((void *)0)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure></p><h2 id="section">0</h2><p>因此在 <code>C++</code> 中，定义一个空指针： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *p = <span class="hljs-literal">NULL</span>;<br></code></pre></td></tr></table></figure> 实际上就是将指针 <code>p</code> 赋值为零。在 <code>C++</code> 中为0的指针都会被认为是空指针。 但是这样的话，就会造成一些歧义：0 即可以表示整数常量，又可以表示空指针常量。那么在下面的经典例子中： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span> </span>&#123;&#125;    <span class="hljs-comment">// #1</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-type">char</span>*)</span> </span>&#123;&#125;  <span class="hljs-comment">// #2</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">foo</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure> <code>foo(NULL)</code> 到底应该调用哪个函数？既然 <code>NULL</code> 是指针，它就应该调用 <code>#2</code> ，但实际上 <code>NULL</code> 又被定义为整数0，所以会调用 <code>#1</code> .</p><p>为了解决这种歧义性，于是又引入了一种新的空指针常量 <code>nullptr</code> .</p><h2 id="nullptr">nullptr</h2><p>在 <code>C++11</code> 中引入了一个新的关键字 <code>nullptr</code>，其定义为 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">typedef</span> <span class="hljs-title">decltype</span><span class="hljs-params">(<span class="hljs-literal">nullptr</span>)</span> <span class="hljs-type">nullptr_t</span></span>;<br></code></pre></td></tr></table></figure> 这里 <code>decltype</code> 也是 <code>C++11</code> 中新引入的关键字，用于自动类型推导。</p><ul><li><code>nullptr_t</code> 是一种数据类型，而 <code>nullptr</code> 是一个常数，是该类型的一个实例。</li><li>因此可以通过 <code>nullptr_t</code> 类型创建另一个新的实例。但所有定义为 <code>nullptr_t</code> 类型的数据都是等价的，行为也是完全一致的。</li><li><code>nullptr</code> 是一个编译期常量，其类型为 <code>nullptr_t</code>，它既不是整型类型，也不是指针类型。</li></ul><p>除此之外，<code>nullptr</code> 还有一些其他的特性：</p><ul><li><code>std::nullptr_t</code> 类型并不是指针类型，但可以隐式转换成任意一个指针类型。</li><li><code>nullptr_t</code> 类型数据不能转换为非指针类型，即使使用<code>reinterpret_cast&lt;nullptr_t&gt;()</code> 的方法也不行。</li><li><code>nullptr_t</code> 类型数据不适用于算术运算表达式。</li><li><code>nullptr_t</code> 类型数据可以用于关系运算表达式，但仅能与 <code>nullptr_t</code> 类型数据或者指针类型数据进行比较，当且仅当关系运算符为 <code>==，&lt;=，&gt;=</code> 等时返回true。</li></ul><p>这些特性可以在代码中得到验证： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//nullptr可以隐式转换为char*</span><br><span class="hljs-type">char</span> *cp = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-comment">//nullptr不能转换为非指针类型，任何类型也不能转换为nullptr_t</span><br><span class="hljs-type">int</span> i1 = <span class="hljs-literal">nullptr</span>; <span class="hljs-comment">//error</span><br><span class="hljs-type">int</span> i2 = <span class="hljs-built_in">reinterpret_cast</span>&lt;<span class="hljs-type">nullptr_t</span>&gt;(<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//error</span><br><br><span class="hljs-comment">//nullptr与nullptr_t类型变量可以作比较，当使用==，&lt;=，&gt;=符号作比较时才返回true</span><br><span class="hljs-type">nullptr_t</span> nptr;<br><span class="hljs-keyword">if</span> (nptr == <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//nullptr_t nptr == nullptr</span><br><span class="hljs-keyword">if</span> (nptr &lt; <span class="hljs-literal">nullptr</span>) <span class="hljs-comment">//nullptr_t nptr &gt;= nullptr</span><br><br><span class="hljs-comment">//不能转换为整型或者bool类型</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span> == <span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//error</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">nullptr</span>); <span class="hljs-comment">//error</span><br><br><span class="hljs-comment">//不能进行算术运算</span><br><span class="hljs-literal">nullptr</span> += <span class="hljs-number">1</span>; <span class="hljs-comment">//error</span><br><span class="hljs-literal">nullptr</span> * <span class="hljs-number">5</span>; <span class="hljs-comment">//error</span><br></code></pre></td></tr></table></figure></p><h3 id="与-void-区别">与 <code>void*</code> 区别</h3><ul><li>在 <code>C++11</code> 标准中，<code>nullptr</code> 类型数据所占用的内存空间，与 <code>void*</code> 所占内存空间大小相同，即 <code>sizeof(nullptr_t) == sizeof(void*)</code>.</li><li>语法内涵不同，<code>nullptr</code> 是一个编译期常量，而 <code>(void*)0</code> 只是一个强制转换表达式，其返回的也是一个 <code>void*</code> 指针类型。</li><li>在 <code>C++</code> 语言中，<code>nullptr</code> 到任何指针的转换是隐式的，而 <code>(void*)0</code> 则必须经过类型转换后才能使用。</li></ul><h3 id="nullptr-可能的实现"><code>nullptr</code> 可能的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">nullptr_t</span><br>&#123;<br>    <span class="hljs-type">void</span> <span class="hljs-keyword">operator</span>&amp;() <span class="hljs-type">const</span> = <span class="hljs-keyword">delete</span>;  <span class="hljs-comment">// Can&#x27;t take address of nullptr</span><br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> T*() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">template</span> &lt;<span class="hljs-keyword">class</span> <span class="hljs-title class_">C</span>, <span class="hljs-keyword">class</span> <span class="hljs-title class_">T</span>&gt;<br>    <span class="hljs-keyword">inline</span> <span class="hljs-keyword">operator</span> T C::*() <span class="hljs-type">const</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">nullptr_t</span> <span class="hljs-literal">nullptr</span>;<br></code></pre></td></tr></table></figure><p>源码这部分需要继续学习~</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在 &lt;code&gt;C/C++&lt;/code&gt; 中，为了防止野指针（指针指向的位置是不可知的），我们常常需要将指针赋值为空指针。在 &lt;code&gt;C&lt;/code&gt; 中我们用 &lt;code&gt;NULL&lt;/code&gt; 来表示空指针，而在 &lt;code&gt;C++&lt;/code&gt; 中则有 &lt;code&gt;NULL&lt;/code&gt; 和 &lt;code&gt;nullptr&lt;/code&gt; 两种空指针，并且其 &lt;code&gt;NULL&lt;/code&gt; 的定义也和 &lt;code&gt;C&lt;/code&gt; 语言中的完全不同。我们就在这篇文章中仔细研究一下。</summary>
    
    
    
    <category term="CS" scheme="https://quantum-cyborg.github.io/categories/CS/"/>
    
    
    <category term="C/C++" scheme="https://quantum-cyborg.github.io/tags/C-C/"/>
    
  </entry>
  
  <entry>
    <title>摹状词和存在</title>
    <link href="https://quantum-cyborg.github.io/2017/05/26/Philosophy/%E6%91%B9%E7%8A%B6%E8%AF%8D%E5%92%8C%E5%AD%98%E5%9C%A8/"/>
    <id>https://quantum-cyborg.github.io/2017/05/26/Philosophy/%E6%91%B9%E7%8A%B6%E8%AF%8D%E5%92%8C%E5%AD%98%E5%9C%A8/</id>
    <published>2017-05-26T04:12:57.000Z</published>
    <updated>2023-12-24T16:20:09.968Z</updated>
    
    <content type="html"><![CDATA[<h4 id="当代分析哲学穆尼茨mk-p.164">《当代分析哲学》穆尼茨·M·K，<strong>P.164</strong></h4><h2 id="section"><span id="more"></span></h2><h3 id="否定的存在陈述">否定的存在陈述</h3><ul><li>如何理解有些词对非存在实体的表面上的指示关系问题</li><li>“A和B之间的差别存在”，如果该陈述为假，则不存在“A和B之间的差别”这个短语所指称的对象。</li><li>上述陈述为假可用另一种形式表达：“A和B之间的差别不存在”，但一个不存在的东西怎么能成为一个命题的主词？</li><li>这是关于<strong>否定的存在陈述</strong>问题</li><li>例子：如果“宙斯不存在”为真，则意味着没有“宙斯”这样的实体。另一方面，如果“宙斯”一词是有意义的，就应该存在某个为该名称所指的实体。</li></ul><hr /><h3 id="存在">存在</h3><ul><li><em>存在</em>是属于每个可以设想的事物的性质，是属于每个可能的思想对象的性质</li><li>存在是一切可数的事物的属性</li><li>一种关于存在的本体论观点：你一旦提及任何东西，你就表明了这种东西的存在。<ol type="1"><li>假定A是任何一个可数为1的东西，则A存在</li><li>如果A是无，就不能说它存在</li><li>而“A不存在”，则暗示着存在一个其存在的属性被否定了的东西，因而也就暗示了A存在。</li><li>因此，“A不存在”是无意义的，或者是假陈述。不管A可能是什么，它必然存在</li></ol></li><li>例子：</li></ul><hr />]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;当代分析哲学穆尼茨mk-p.164&quot;&gt;《当代分析哲学》穆尼茨·M·K，
&lt;strong&gt;P.164&lt;/strong&gt;&lt;/h4&gt;
&lt;h2 id=&quot;section&quot;&gt;</summary>
    
    
    
    <category term="Philosophy" scheme="https://quantum-cyborg.github.io/categories/Philosophy/"/>
    
    
    <category term="分析哲学" scheme="https://quantum-cyborg.github.io/tags/%E5%88%86%E6%9E%90%E5%93%B2%E5%AD%A6/"/>
    
  </entry>
  
</feed>
